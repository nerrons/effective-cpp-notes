<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Effective C++</title><style>
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}
.select-value-color-default { background-color: rgba(206,205,202,0.5); }
.select-value-color-gray { background-color: rgba(155,154,151, 0.4); }
.select-value-color-brown { background-color: rgba(140,46,0,0.2); }
.select-value-color-orange { background-color: rgba(245,93,0,0.2); }
.select-value-color-yellow { background-color: rgba(233,168,0,0.2); }
.select-value-color-green { background-color: rgba(0,135,107,0.2); }
.select-value-color-blue { background-color: rgba(0,120,223,0.2); }
.select-value-color-purple { background-color: rgba(103,36,222,0.2); }
.select-value-color-pink { background-color: rgba(221,0,129,0.2); }
.select-value-color-red { background-color: rgba(255,0,26,0.2); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="73e0037b-eb02-4637-b5e5-e08848f8d4fd" class="page serif"><header><div class="page-header-icon undefined"><span class="icon">⚔️</span></div><h1 class="page-title">Effective C++</h1><table class="properties"><tbody><tr class="property-row property-row-select"><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesSelect"><path d="M7,13 C10.31348,13 13,10.31371 13,7 C13,3.68629 10.31348,1 7,1 C3.68652,1 1,3.68629 1,7 C1,10.31371 3.68652,13 7,13 Z M3.75098,5.32278 C3.64893,5.19142 3.74268,5 3.90869,5 L10.09131,5 C10.25732,5 10.35107,5.19142 10.24902,5.32278 L7.15771,9.29703 C7.07764,9.39998 6.92236,9.39998 6.84229,9.29703 L3.75098,5.32278 Z"></path></svg></span>Class</th><td><span class="selected-value select-value-color-pink">C++</span></td></tr><tr class="property-row property-row-created_time"><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesCreatedAt"><path d="M6.98643729,14.0000972 C5.19579566,14.0000972 3.40419152,13.3106896 2.04245843,11.9323606 C-0.681017475,9.21200555 -0.680780251,4.76029539 2.04293482,2.04012507 C4.76664406,-0.68004331 9.22427509,-0.68004331 11.9480135,2.04013479 C13.272481,3.36277455 14,5.1330091 14,6.99552762 C14,8.87640182 13.2721894,10.6285043 11.9480135,11.9509302 C10.5679344,13.3105924 8.77756503,14.0000972 6.98643729,14.0000972 Z M10.2705296,7.00913883 L10.2705296,8.46099754 L10.2705296,8.65543362 L10.076181,8.65543362 L8.6543739,8.65543362 L5.72059514,8.65543362 L5.52619796,8.65543362 L5.52619796,8.46099754 L5.52619796,5.52541044 L5.52619796,3.37946773 L5.52619796,3.18502193 L5.72059514,3.18502193 L7.17253164,3.18502193 L7.36692883,3.18502193 L7.36692883,3.37946773 L7.36692883,6.81467358 L10.076181,6.81467358 L10.2705296,6.81467358 L10.2705296,7.00913883 Z M12.1601539,6.99552762 C12.1601539,5.61697497 11.6190112,4.32597154 10.6393933,3.34769528 C8.63253764,1.34336744 5.35197452,1.34061603 3.34153136,3.33944106 C3.33868273,3.34219247 3.33607716,3.34494388 3.33322852,3.34769528 C1.32397148,5.35459953 1.32372842,8.63641682 3.33322852,10.6433794 C5.34295224,12.6504489 8.62968901,12.6504489 10.6393933,10.6433794 C11.6190112,9.66506426 12.1601539,8.37408027 12.1601539,6.99552762 Z"></path></svg></span>Created</th><td><time>@Jun 4, 2020 6:28 AM</time></td></tr><tr class="property-row property-row-date"><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesDate"><path d="M10.8889,5.5 L3.11111,5.5 L3.11111,7.05556 L10.8889,7.05556 L10.8889,5.5 Z M12.4444,1.05556 L11.6667,1.05556 L11.6667,0 L10.1111,0 L10.1111,1.05556 L3.88889,1.05556 L3.88889,0 L2.33333,0 L2.33333,1.05556 L1.55556,1.05556 C0.692222,1.05556 0.00777777,1.75556 0.00777777,2.61111 L0,12.5 C0,13.3556 0.692222,14 1.55556,14 L12.4444,14 C13.3,14 14,13.3556 14,12.5 L14,2.61111 C14,1.75556 13.3,1.05556 12.4444,1.05556 Z M12.4444,12.5 L1.55556,12.5 L1.55556,3.94444 L12.4444,3.94444 L12.4444,12.5 Z M8.55556,8.61111 L3.11111,8.61111 L3.11111,10.1667 L8.55556,10.1667 L8.55556,8.61111 Z"></path></svg></span>Finished</th><td><time>@Jun 30, 2020</time></td></tr><tr class="property-row property-row-select"><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesSelect"><path d="M7,13 C10.31348,13 13,10.31371 13,7 C13,3.68629 10.31348,1 7,1 C3.68652,1 1,3.68629 1,7 C1,10.31371 3.68652,13 7,13 Z M3.75098,5.32278 C3.64893,5.19142 3.74268,5 3.90869,5 L10.09131,5 C10.25732,5 10.35107,5.19142 10.24902,5.32278 L7.15771,9.29703 C7.07764,9.39998 6.92236,9.39998 6.84229,9.29703 L3.75098,5.32278 Z"></path></svg></span>Type</th><td><span class="selected-value select-value-color-gray">Book</span></td></tr></tbody></table></header><div class="page-body"><nav id="af81dad0-ff6d-4347-84e0-2948af560111" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#09d0a6de-3cb6-48b9-954e-e69c852a0f54">Introduction</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#705ea5c7-de05-4b60-91f0-5b5b5844c6fa"><strong>Terminology</strong></a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#3f5089dd-2a2e-48dc-a5f5-fdb9e8156640">Accustoming to C++</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2c274dad-45aa-4d11-ad0c-ff93fd5613eb">1 C++ is a federation of languages</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#7e2c6262-4afd-47ae-9ca6-259028d9991b">2 <code>const</code>, <code>enum</code>, <code>inline</code>&gt; <code>#define</code></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#a9d766d2-6cab-430e-bc02-043f890e7436">3 Use <code>const</code> whenever possible</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#72960e91-c4cc-4e34-a6f5-aeae9202745c">ROT</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#0666d6fb-27c0-43f8-af10-55d01f44571b">raw pointers:</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#be0e9160-4a26-4ef8-ab95-fa1bc002489d">iterators</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#29d85855-7579-4782-a61f-304a2597bafe">functions</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#7cf5b63f-a515-48c6-8457-e332085841f9">4 Ensure init before use</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#dfeebbf9-6394-4aa8-8b77-16b52cc50c8e">ROT</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#d29afbbf-5b92-43c2-8a44-c5249788e651">init&#x27;n for built-in and user-defined types</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#400a68bc-b165-497c-a699-480f70bf30fc">order of init&#x27;n</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#469a8c0b-c763-42e7-9831-9de921221cbd">Ctors, Dtors and <code>operator=</code></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e3cd8e5c-fe3e-4964-89f3-7d600b6dc778">5 Know default behaviour</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#3482ebb2-53f3-4c20-8e14-12e680dce4dd">6 Disallow generated functions you don&#x27;t want</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#cc3aff8f-b717-4de6-8272-94ade9e9fdcb">7 Make dtors virtual in polymorphic base classes</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#efc42bce-f359-404a-bf04-597b7c4ba888">reason</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#9d8dbd8b-2559-4405-abf3-6484fc951697">pure virtual dtors</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#30b88d52-2613-4ab5-ba8e-1c741644a483">8 Prevent exceptions from leaving dtors</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#a654eefd-5e97-4b74-8bfb-01d873f98e0e">ROT</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#9e2d0ca6-fcf2-44f0-bf74-de3dcb797524">reason</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#d7c35b18-ad7a-45a9-b6e2-ba6c7756d555">problem &amp; solutions</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#6a6427b9-ba98-4b3b-b79c-68d58d06a306">9 Never call virtual funcs during constr&#x27;n or destr&#x27;n.</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#2c385769-75dc-4082-9c49-34323f05e9a6">ROT</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#c5f968d6-4a5a-47aa-a309-701d00a35b54">reason</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#0d4e2f88-5072-4878-a6a6-8d5c80c1692a">object type treatment model</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#9b25875b-d53a-4c35-b30d-6f4629082c96">problem &amp; solutions</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#538b438d-7fee-450a-b501-92e394bcf6a3">10 Have assignment operators return a reference to <code>*this</code></a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#6828697f-9078-4638-b3c6-5b4f7617e1e8">ROT</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#85d399cd-10a9-457e-a0b2-73ac1d5aecc1">11 Handle assignment to self in <code>operator=</code></a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#444acb77-b97c-4a40-b1c3-93053d27db41">ROT</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#b22ad7dc-d474-46d8-a7df-4375e26731c6">problem</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#59d5af37-592f-4460-812f-bda1f9366d13">solutions</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#cb4c32e4-25ae-4733-8ff2-9d2e42b67ed8">12 Copy all parts of an object</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#f32adfe5-25dc-4713-948f-55c0c850bb4b">ROT</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#a95f3772-8f94-414a-b1ca-3746d5e247c9">potential partial init&#x27;n</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#92d8a11a-ebde-45cb-a776-11a08b401ad5">init&#x27;n of subclasses</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#89a674fe-c9b6-4890-8e40-a9d3b719841d">boilerplate</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#f6c3f007-4b30-490d-b44b-0b616e0c2073">Resource Management</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#1a059705-eb30-4021-b7ca-18cbf8e22942">13 Use objects to manage resources</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b290ada5-4527-40ef-b0a3-89cb33899bf9">14 Think copying behavior in resource-managing classes</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#900cf5a2-c0f4-456d-b7a7-4500686630bb">prohibit copying</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#fd7aa2d7-5e62-466b-ac95-cb7b4f130a5b">reference-count the underlying resource</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#4c65bb2f-1303-4bd5-96b1-5177fd721e95">copy the underlying resource</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#89aa1c39-a3f8-4710-8951-4760c2852500">transfer ownership of the underlying resource</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b4f36b36-5322-417f-8ffe-6bd6673ff1cc">15 Provide access to raw resources in res-mng class</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#23db9612-59b7-4960-a7bb-7a5e19c53995">ROT</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#ce10f4a5-b97a-420e-9849-82a2226ad888">reason</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#184e0aff-4a61-4ac6-894f-8f0b27224f98">in practice</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#9f2981d1-f937-4a4e-a684-da541b6c64ee">16 Use matched <code>[]</code> in <code>new</code> and <code>delete</code></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#832fef6c-2614-4529-9ef9-ee9e0495f67c">17 Store <code>new</code>ed objs in smart ptrs in standalone statements</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#d671bed6-e5f2-43eb-a97b-ff1059062170">ROT</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#071b2621-ec21-4394-9535-c8a84e1b3788">scenario</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#cbe9c191-f209-4d80-bbf4-6143f4a46edf">problem</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#893426b4-8a44-47d7-a49f-1fe428f6ce26">solution</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#07b79c8d-b80f-49e9-95a7-d686377dfb1e">Designs and Declarations</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#3350906f-e319-408b-9986-7e10c28d3c67">18 Make interfaces easy to use right and hard to use wrong.</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#ab7f83c3-ad3b-439e-a7be-89b7d0c35987">ROT</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#4d50c5b5-e13e-4883-be68-f4decffe8cb5">anticipate mistakes</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#f0f273a5-2ddf-4206-87bb-c6881c45e777">establish consistency among built-in types and other similar types</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#3f08140a-2410-4e3d-ab00-b0ddaf6ed42a">reduce things that the client needs to remember</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#9fba3050-2173-4c26-b46e-8467c219dcd4">19 Treat class design as type design</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b3944e66-aaec-4c61-be73-fcbc3d9ab39a">20 Prefer pass-by-ref-to-<code>const</code> to pass-by-value</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#d17a59a5-6d93-4d99-ae69-2ca2b0b38386">ROT</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#f2c6a259-3b63-4ad6-bbeb-fdd87dbe3ad3">reason: performance</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#531e46c4-4b06-4115-990c-edb50bcddc18">reason: slicing</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#f0045b51-e23b-43b2-9443-2fc1f606ebb8">knowledge</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#d5e97720-b03a-42f3-9672-b55760860a1b">21 Don&#x27;t return ref to local obj when returning an obj</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#6fe62330-1f56-4fa5-9e77-3528e16c6e8f">ROT</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#4b1cc0c2-e71b-4203-9a6e-0ae5b1ec227b">reason</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2f919d64-6fab-4686-988e-0327fcf5d404">22 Declare data members <code>private</code></a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#01dddd4c-924f-4e3d-b67c-16e2af0e47af">reason aginst <code>public</code></a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#1adb1be4-68a0-4d41-8175-0d2ec9b016b2">reason against <code>protected</code></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#a89b6b79-2ab2-4ad3-84da-3166e1cc2e3c">23 Prefer non-member non-friend funcs to member funcs</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#a1e3dc2e-7120-46a3-97f0-f68156ab2412">ROT</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#c9b7f947-707e-4543-9d05-5f4987dfbcfe">scenario</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#cc157b02-4ed3-471a-b685-29c6091e3d39">encapsulation</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#aa58f01a-cf8b-4e82-baed-2ba9176bf0d4">in practice</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#f6865af8-8753-461c-9353-2e6dc93ce666">24 Declare non-member funcs when type conversions should apply to all params</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#c69f04ad-acf3-4ce7-8de0-1bce5fad6a21">25 Consider support for non-throwing <code>swap</code></a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#c39c2a61-22c3-4a06-a809-b88d174fd84b">background</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#e9b6e634-736d-4b3f-bdc4-590be2d9c320"><code>std::swap</code> with a member <code>swap</code></a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#16b56dcd-9dad-495f-a10c-7d69cd152ff9">when it&#x27;s a class template</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#ba98de57-cc66-4916-84fc-79fd3a705225">making it easy for the clients to call the correct version</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#e92554ea-a02b-43ad-b2f9-ba12923b3c45">recipe</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#e5f26973-5abc-4e8e-b4b1-ca7f6392e180">Implementations</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e08e6a0d-b999-466d-a228-78120b58d3ea">26 Postpone variable definitions as long as possible</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#37f362cc-ca63-4309-908a-f2c1fddf5579">27 Minimize casting</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#dbabe823-8fef-4af6-a601-1d256454a0dd">ROT</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#1c345d70-7434-4ac6-bc04-e2e61e095ff5">new-style casts</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#5051edeb-afbb-4c9e-84db-ac02f861f1e3">type conversions modify values</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#58740005-3311-4f8d-9533-712cb8d8498e"><code>static_cast</code> might make a copy</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#dbe246a6-d67c-499a-81a2-932ccf74612d">refactoring <code>dynamic_cast</code></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#22296d3c-d49b-451d-a45a-d227fa03acbf">28 Avoid returning handles to object internals</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#ce8bf516-ddee-4acf-b266-90b0c3a21339">scenario</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#67ecb787-a347-4b8b-b686-4250d7127994">29 Strive for exception-safe code</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#2a87d7b2-d579-40eb-b587-48cab8bd951a">ROT</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#49fd3467-141f-4e2c-a182-414113211b2d">requirements for exception safety</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#81c65167-eebd-4629-921e-58670c76baae">three guarantees</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#00143daf-5a9b-4cbd-b5d5-f0b08938a77f">fine-tuning statements to improve exception safety</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#caa05c3f-ffe4-4f9b-9da9-15b6abf2715a">copy-and-swap</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#c991bcd1-08fc-45ef-be98-29e3f13d43cb">not a panacea</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#a8fc177d-abc6-448d-a707-e2fe7439b28f">insights</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#04eefa07-fd57-43eb-b724-5ba89fd9139b">30 Understand inlining</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#06ea5863-0a4a-4373-b3b5-74099bab80a4">ROT</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#01c98fe8-20b7-4bc6-a413-fff2b2c9997d">declaring an inline func</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#8bf95f38-c5b2-483b-843e-3710689e36dd">inline and template</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#3fc254e0-7251-483b-8214-8394461c068e">compilers and inlines</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#18869f2b-4779-4b4f-8cb9-4fc711b709f8">31 Minimize compilation dependencies between files</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#0919e9ff-55fc-443f-a21e-08c07f98e5a8">problem</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#bb8f6d0e-7763-470a-9d6a-3af5ae0f40d1">dependency chain</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#d08a2e85-9be2-467f-ad0b-6729f8f7f257">essence</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#56a00920-2b0c-4e1e-8e79-67587afb604b">handle class (pimpl idiom)</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#7a472785-092e-469b-aaf6-a4a669f3327e">advice regarding handle class</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#878a54cb-a0c4-4d94-8e81-70d6ded1668d">interface class</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#0d187631-a776-4696-a413-fa02b46a8460">Inheritance and OOP</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#f21376e7-376b-4689-90d1-2cb9768390bd">32 Make sure public inheritance models &quot;is-a&quot;</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#45cb4b4f-ec4f-4e15-8b54-14122ba26356">semantics</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#dd7228c1-50df-4e2b-b6d2-8ce36dee3f2e">caution</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#9122796c-efe4-460a-a825-e6b9e2c8bd10">33 Avoid hiding inherited names</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#d0336f2a-d836-466d-8c0c-fcfa5c14f824">hidden overloads</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#615a8ccb-9518-4324-8fa2-c29d9e333d6e">solution for public inheritance</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#80d78849-3656-4c7f-a874-1910bde18203">solution for private inheritance</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#9a095792-c765-4ecd-b7ae-3f99059f22de">34 Differentiate between inheritance of interface and inheritance of implementation</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#a02514ff-6b06-4be7-ada3-d06589c049a1">pure virtual function</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#bee6aac9-7a0a-4d4d-9e0d-e5842c09d7a5">impure virtual function</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#18d1d3a8-ad94-41f4-9dda-6b9c00c55ccd">non-virtual function</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#b27a2a74-d3c6-469f-9880-3d7026b95965">common mistakes</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#17dbd582-e34f-46e2-9e7a-edf76d0a8e68">35 Consider alternatives to virtual functions</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#9075ab14-4d18-46e3-80d3-faf8f3ab96d0">ROT</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#94cdb265-e4b7-4f13-a5e7-4a36499b7ebf"><em>template method pattern</em> via <em>non-virtual interface</em> idiom</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#995c6c81-6a13-487c-a148-8bf9f3d72849"><em>strategy pattern </em>via function pointers</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#f0bd1609-58a7-403c-b2c8-3b06651db636"><em>strategy pattern </em>via <code>function</code></a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#2a2d0fd7-5e0f-4475-a7b3-aed2bd55a564"><em>classic strategy pattern</em></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#66f605a2-ec3f-46f8-9444-4efc55142326">36 Never redefine an inherited non-virtual function</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#bc5fb5db-4df0-4469-b03f-bc9e5ee411c8">37 Never redefine a func&#x27;s inherited default param value.</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#0e37efad-cf69-44ea-a47f-1803dd8afe5d">static &amp; dynamic types</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#e4650383-af1e-440f-84a9-9e37562e1932">the keng</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#9740dbf8-b9e7-44f7-9cbd-d923100fb699">solutions</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#463ded3f-a558-479e-89b7-5feb587a2eaf">38 Model &quot;has-a&quot; &amp; &quot;impl&#x27;ed-in-terms-of&quot; via composition.</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#a748b2e9-948b-4a90-9b49-edfc1cd1c4bb">terminology</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#9b5f3678-5d34-4940-a80a-518b53d2e8c2">diff between &quot;is-a&quot; &amp; &quot;impl&#x27;ed-in-terms-of&quot;</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e31c27c2-b54d-4058-ae58-6c66fd9a9015">39 Use private inheritance judiciously</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#3b5f5b7f-e21e-4afb-b9a2-ccf2e9d11070">ROT</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#dcd0d169-2372-4cb4-aa8b-c5625850dfa6">behaviour of private inheritance</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#dc79e492-528d-4cb6-bb11-a8c885f87356">meaning</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#e26a79e9-959d-4c9e-9e81-9a6e6350897d">when to use</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#efa19b46-a82a-429d-b6a0-9187f38af56d">example: integrating a utility class</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#2a61dd33-cc2b-4ef7-a068-397c3dd6533d">edge case: <em>empty base optimization</em></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#55f75a26-6144-43c5-9644-d1c2b5537acd">40 Use multiple inheritance judiciously</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#0bf45091-f89c-4f6b-987d-46de3db1e725">problems with MI</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#c687d83a-5a58-410c-9329-14c55cdfaed2">One possible use...</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#6467c496-3942-4ccf-8f12-8711ec5b2f5e">Templates and Generic Programming</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#39e4ed04-8e7b-4e79-8b7e-e2cbb36ce462">41 Know implicit interfaces &amp; compile time polymorphism</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#3a91acbe-0d56-498e-be78-502258d03adc">explicit vs implicit; compile time vs runtime</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#c7f6d1fd-7d75-45c9-b76d-cb6b0b3e7f3d">more on explicit and implicit interfaces</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#fd504892-a293-4e36-9bce-21a3a2626a57">42 Understand the two meanings of <code>typename</code></a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#926c9b93-a5e5-40ec-83b4-de823705162c">asserting nested dependent type names</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#d6a5d093-db7c-40ae-8738-04477f3298dd">43 Know how to access names in templatized base classes</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#6af1c344-982e-4858-90d2-582e9b9c09d1">reason</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#05719736-c64b-4785-8466-11098918d231">solutions</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#33478433-ba32-4151-8940-0fdf259dfd31">44 Factor parameter-independent code out of templates.</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#0b102f00-ae98-4741-9fb3-4c0e8bdcc6ca">ROT</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#e9b22283-b081-4814-8adc-769469a8f6b8">terminology</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#706418a2-e0b0-47af-9c81-246868bf4138">implicit replication about templates</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#82f857e3-8e57-45d7-88eb-d0d30f790290">scenario</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#6ad215fb-0ad4-4a3a-bf21-ffc6febab2b3">conclusion</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#f99461f7-cf52-41a4-b496-f9d633f18255">45 Use memfunc templates to accept &quot;all compatible types&quot;</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#9940cb94-afb7-4df2-9c61-bcdcabe87f17">ROT</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#bdaf4fdf-7350-43eb-85c5-c6457093a3bf">background</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#944e8c90-982f-472e-9d14-0aca62dd37ba">appetizer: <em>general copy ctors</em></a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#47ebe655-d411-453d-ae9a-c66d34135dac">supporting assignments and other conversions</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#df9a66ec-ff8a-48c6-88bb-426c11258725">about the default ctors/operators</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#9297ec22-6c5b-40bb-94c5-be3577595942">46 Define non-member functions inside templates when type conversions are desired</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#6409672a-c20c-4212-b7ab-10b302eb9167">ROT</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#aedbb513-027e-40cc-a8a2-056996af9ff8">problem: function templates doesn&#x27;t have implicit conversions</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#80fc0a4d-1505-4d46-88f0-451f12ddfdd3">solution: <code>friend</code> inside class template</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#233aa0e1-dbce-4a80-bc7c-9cc46d89d162">improvement: minimize inlining</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#168357ed-4758-4afb-8663-1d04c8d0eaad">47 Use traits classes for information about types</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#18932b8a-469f-42f2-9f74-9b6b40473ef7">mini review: 5 types of iterators</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#d7912891-a103-45cf-9135-bbfa7b951493">iterator tag</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#7a2e6552-634f-4ea4-a247-d0827f73f895">introducing traits</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#ee83aed2-b6d2-4edc-a440-9443b2c69da4">traits and user-defined classes</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#0840fc6b-72b1-4cd4-b20d-a48d27af8140">traits for built-in types</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#aafad101-3c63-485c-8d6f-122e45a70e27">procedure of designing and implementing traits</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#d8543011-f65a-43a8-9d31-d1c1e6409d11">using traits</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#0bad65d3-5896-4b45-86c6-beed688f888d">48 Be aware of template metaprogramming</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#7c7a1605-fb25-4ed9-9b7e-b3c4f38da571">Hello World: factorial</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#4d8566c7-19b5-4891-aa4f-3a63294afc3a">why even bother</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#bc079859-94f8-4e3d-a088-90a3c115b298">Customizing <code>new</code> and <code>delete</code></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#4210a4c1-a85e-48e2-89b2-a5cc95d5550d">49 Understand the behavior of the new-handler</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#a8e0223c-12f1-46b3-ac5e-b7c7d5f946e2">ROT</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#aa80ee24-3562-47ea-a62a-cd4e491d3a0b">introducing new-handlers</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#bd57cd3c-6ae2-433b-a376-cf050160c10b">writing new-handlers</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#63ce1392-7e31-4e3f-92cb-5964ed2edbc4">proposal for class specific new-handlers</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#ccfc31fa-633e-4ef7-beb9-24c2641585aa">implementing class specific new-handlers</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#4d16c54f-323d-4764-81ea-51b483e2f841">reusing the class-specific new-handler feature</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#8adfc17b-ef2b-4a07-bd74-d39a2f778271">legacy nothrow operator new</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#85724b1e-956b-4d00-8ee8-7175bbbcc00b">50 When necessary, replace <code>new</code> and <code>delete</code></a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#0d6016ae-ea4d-4fde-9cb6-9e4899d84747">why the black magic</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#d5438a57-c084-4d12-8531-f42f97aac04c">over/underrun detection using signatures</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#59da1662-1c3d-446c-a0cf-bce6cb7411c6">alignment</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#090b3773-020d-4f6d-a4bd-50600819858d">alternatives</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#4934ebc0-75b7-40ec-9c56-0dde35495a30">51 Adhere to convention when writing <code>new</code> and <code>delete</code></a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#f411806c-0998-489a-ab7c-a0c7a4ad25da">ROT</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#99f43370-da29-40bd-bf52-7a857d10f5ae">conventions for<code>new</code></a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#dc16389d-9647-48ce-bf74-e321f4e1747f">conventions for <code>delete</code></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#3fdf33f0-f035-4ffb-b8f6-4ad241d18df2">52 Write placement <code>delete</code> if you write placement <code>new</code></a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#a755438e-08cb-4468-bd7c-e8441295d5c5">ROT</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#46bc191f-bfcb-4f8c-93ff-5384281d2a11">terminology</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#9d7c5830-6bda-4a24-8ac4-7fb01f21df08">compilers taking care of exceptions thrown when <code>new</code>ing</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#e08b50fe-aa57-4aa4-8280-ed658d72c603">providing full support for <code>new</code> and <code>delete</code></a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#03c5b93b-a2bf-498e-9858-1bb86afcc796">Miscellany</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#5bc23f38-1f4b-42f6-99e1-6582e8f6bc59">53 Pay attention to compiler warnings</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#4b91c652-bbf0-4ea1-af82-9ac3fd926f87">54 Familiarize urself with standard libraries</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#bb122234-7fe5-40a5-91dc-bec26e03df3f">C++98</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#1fcf2339-5c49-4539-8588-24252d26c65d">C++0x</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#38e1c7ac-eea2-4722-a212-1ae60b626547">55 Use <code>Boost</code>.</a></div></nav><h1 id="09d0a6de-3cb6-48b9-954e-e69c852a0f54" class="">Introduction</h1><p id="dabe2f0c-4bc9-453b-ad00-d2eaf151d9c2" class="">C++ offers too much. To write effective C++, you need to</p><ul id="29eea22c-68f5-4597-9442-b16f361fa2ec" class="bulleted-list"><li>make design decisions, from big (class hierarchy) to small (pass-by-reference or pass-by-pointer)</li></ul><ul id="f60cfe1e-7bd5-40c1-99d0-774111b038e4" class="bulleted-list"><li>make those decisions happen. It&#x27;s not easy.</li></ul><h3 id="705ea5c7-de05-4b60-91f0-5b5b5844c6fa" class=""><strong>Terminology</strong></h3><p id="23ce4e24-765e-4ae1-8ff7-8cc3344c9708" class=""><a href="https://www.notion.so/Effective-Modern-C-a079f59a1a40420cab6a2dcaa7f593db#70bbc330e3d54dfdbf8d030e1f01466d">See EMC++</a></p><h1 id="3f5089dd-2a2e-48dc-a5f5-fdb9e8156640" class="">Accustoming to C++</h1><h2 id="2c274dad-45aa-4d11-ad0c-ff93fd5613eb" class="">1 C++ is a federation of languages</h2><p id="24902906-3f7c-4a30-b2aa-979b8930024f" class="">At least 4 sub-languages:</p><ul id="70c78fdc-d9ca-4480-9587-0cdf491ab075" class="bulleted-list"><li><strong>C.</strong> Classic. No templates, exceptions, overloading, etc.</li></ul><ul id="14790fd3-1a3e-4421-b862-18d2a7051812" class="bulleted-list"><li><strong>Object-Oriented C++.</strong> C with Classes. Encapsulation, inheritance, polymorphism, virtual functions, dynamic binding. Apply traditional object-oriented design.</li></ul><ul id="c7cd314b-df1f-4516-9779-805bf12961a5" class="bulleted-list"><li><strong>Template C++</strong>. Generic programming. A different set of rules. Fret not.</li></ul><ul id="41969fdd-aeb2-4222-b9d6-30765cd743d6" class="bulleted-list"><li><strong>The STL.</strong> Has particular ways of doing things. Follow conventions.</li></ul><p id="54467c5b-ded2-4cea-870c-a25289d2d471" class="">Examples:</p><ul id="85ba67d5-ea79-4035-b813-1776bb6a4a61" class="bulleted-list"><li>Pass-by-value is efficient in C. Not for OOC++ and Template C++. But for STL with iterators, the rules apply again.</li></ul><h2 id="7e2c6262-4afd-47ae-9ca6-259028d9991b" class="">2 <code>const</code>, <code>enum</code>, <code>inline</code>&gt; <code>#define</code></h2><p id="86a57d65-63ea-4aa4-a9d1-c0bf19cbbcd6" class="">Or, prefer compiler to preprocessor.</p><ul id="e7c04e5b-af31-421a-a2fd-78930b6fc30c" class="bulleted-list"><li>Note: now to replace macro constants use <code>constexpr</code> instead of just <code>const</code>.</li></ul><ul id="5221526e-4e03-476f-a974-f567b78bde10" class="bulleted-list"><li><em>The enum hack</em>: uses a enum in a class to simulate <code>#define</code>. It&#x27;s behaviour is more close to <code>#define</code> so it&#x27;s widely used.</li></ul><ul id="5a885a7f-0d22-413b-8adb-ac1d49bf9341" class="bulleted-list"><li>For macro functions, use templates, <code>constexpr</code> and <code>inline</code>.</li></ul><h2 id="a9d766d2-6cab-430e-bc02-043f890e7436" class="">3 Use <code>const</code> whenever possible</h2><h3 id="72960e91-c4cc-4e34-a6f5-aeae9202745c" class="">ROT</h3><ul id="1501e593-6fca-45dd-a34c-b23eff67b7c4" class="bulleted-list"><li>declaring <code>const</code> helps compilers to find usage errors</li></ul><ul id="7cef9a59-5a76-4f94-9e6d-37be487fe82b" class="bulleted-list"><li><code>const</code> can be applied to objects at any scope, function parameters, return types, and member functions as a whole</li></ul><ul id="5d89f39a-7824-4cd9-b7d9-76a11ea1b3e5" class="bulleted-list"><li>for member functions, compilers check bitwise but you should use logical</li></ul><ul id="8941a9b0-bf5b-46ea-8b77-15d25f1650ea" class="bulleted-list"><li>for duplication in versions of member functions, let the non-<code>const</code> call the <code>const</code></li></ul><h3 id="0666d6fb-27c0-43f8-af10-55d01f44571b" class="">raw pointers:</h3><ul id="f2e23924-ab91-4dbb-8f4c-93f5f56cfb05" class="bulleted-list"><li><code>const</code> on the left applies to the target type; <code>const</code> on the right applies to the pointer itself.</li></ul><ul id="9307d20f-b6ca-4642-8d9f-b08ea8f1a072" class="bulleted-list"><li><code>const Widget *pw</code> and <code>Widget const *pw</code> are equivalent, as the <code>const</code> appears on the left of the star.</li></ul><h3 id="be0e9160-4a26-4ef8-ab95-fa1bc002489d" class="">iterators</h3><ul id="87404d0f-107e-4b73-a57b-47062ad97a77" class="bulleted-list"><li>2 places to apply <code>const</code></li></ul><ul id="8143edc6-163c-4425-bc27-f985426839af" class="bulleted-list"><li><code>const T&lt;S&gt;::iterator</code> declares the iterator itself constant (very naturally! It&#x27;s no different to <code>const int</code>). </li></ul><ul id="5be11455-b2b2-4899-829c-42d73e1cde09" class="bulleted-list"><li><code>T&lt;S&gt;::const_iterator</code> disables modifying the target element.</li></ul><h3 id="29d85855-7579-4782-a61f-304a2597bafe" class="">functions</h3><ul id="2810deb3-e289-4540-b308-7d1877a88cf0" class="bulleted-list"><li>3 places to apply <code>const</code> (return type, params, whole function if member function)</li></ul><ul id="cb61d1f6-06c4-4196-bb31-25e5cc981c73" class="bulleted-list"><li>Sometimes it&#x27;s necessary to return <code>const</code> types to disable assigning something to the returned value</li></ul><ul id="e5e0ef08-d6c9-4f2d-a9df-c2ba6003779e" class="bulleted-list"><li><code>const</code> member functions<ul id="bd1a2707-519b-49ec-8e2d-4992997daad2" class="bulleted-list"><li>For a const object, only <code>const</code> member functions can be invoked</li></ul><ul id="1059eb24-8a59-4668-ab2d-eca94d47649e" class="bulleted-list"><li>You can overload functions whose signatures only differ in <code>const</code>ness</li></ul><ul id="31fea40f-b384-4859-896b-292e8a7edc04" class="bulleted-list"><li>Two philosophies for deciding whether a member function should be <code>const</code><ul id="0503eec9-7edd-4a91-b87d-fdb4679f3822" class="bulleted-list"><li>Bitwise: member funcitons should be <code>const</code> iff they don&#x27;t modify data members. This is how the compiler thinks by default.</li></ul><ul id="fa91f09d-e2a3-466e-80ae-1b2957c461c1" class="bulleted-list"><li><strong>Logical</strong>: member functions should be <code>const</code> iff it doesn&#x27;t modify any member the client can see.<ul id="a623f826-458c-42b2-90d6-e93ade4af205" class="bulleted-list"><li>e.g. it&#x27;s OK to update internal cache, even when the object is <code>const</code>.</li></ul><ul id="53ceb9c5-2f30-45a9-b0f5-e5c381efdae3" class="bulleted-list"><li>To make compilers happy, use <code>mutable</code> when declaring fields than can be modified by <code>const</code> member functions.</li></ul></li></ul></li></ul><ul id="60b28185-c3ec-405a-887b-e4d4ceda9d0f" class="bulleted-list"><li>To reduce boilerplate code between <code>const</code> and non-<code>const</code> version of the exact same function, use casts so non-<code>const</code>calls <code>const</code>.<p id="8ed9890b-79e5-49e4-8a90-7b53cac60225" class="">Note that don&#x27;t do it the other way around: it might break the promise that <code>const</code> member functions must not modify the object.</p><pre id="2060773e-9df4-4468-a7ec-41e1b16ec1f4" class="code"><code>const T&amp; f() const {
    return something_complicated();
}
T&amp; f() {
    return const_cast&lt;T&amp;&gt;(std::as_const(*this).f());
}</code></pre></li></ul></li></ul><h2 id="7cf5b63f-a515-48c6-8457-e332085841f9" class="">4 Ensure init before use</h2><h3 id="dfeebbf9-6394-4aa8-8b77-16b52cc50c8e" class="">ROT</h3><ul id="83829f00-a8f7-43dd-87a6-b29652455325" class="bulleted-list"><li>reading uninitialized values is UB. Thus, always initialize objects before use.</li></ul><ul id="3bd9a9de-7213-4282-ac45-92c04eb26130" class="bulleted-list"><li>manually initialize built-in type objects</li></ul><ul id="b1228cc3-7266-485a-b8f5-94a2cdd79ade" class="bulleted-list"><li>in ctor, prefer member init&#x27;n list to assignment inside body.</li></ul><ul id="ddee3aef-9e5f-4f9d-b6b7-2612d83d8aba" class="bulleted-list"><li>list data members in the same order they&#x27;re declared in class</li></ul><ul id="dfbb2339-c623-420f-85ea-eed60b8a7284" class="bulleted-list"><li>replace non-local static objects with local static objects</li></ul><h3 id="d29afbbf-5b92-43c2-8a44-c5249788e651" class="">init&#x27;n for built-in and user-defined types</h3><ul id="3402569f-4f29-4171-84e6-42b0feb0a66e" class="bulleted-list"><li>For non-member objects of built-in types (like a global <code>int</code> or <code>double</code>), it must be done manually.</li></ul><ul id="4741d1fe-327e-41d1-a0dd-93b39d095bab" class="bulleted-list"><li>For almost everything else, the responsibility for init falls on constructors. Must ensure ctors you write initialize all members.<ul id="c752f5af-e2d6-4427-81a9-115280bea307" class="bulleted-list"><li><em>Don&#x27;t </em><em><strong>assign</strong></em> to members in ctor body (which calls the default ctor and immediately copy-assigns a new value); use the <strong>member</strong> <strong>initialization list </strong>for efficiency, since only one copy construction happens.<ul id="ae978cbc-650b-4614-bae8-7e84d1e148f4" class="bulleted-list"><li>For data members that are <code>const</code>, you can&#x27;t even assign them.</li></ul></li></ul><ul id="144ebcb7-7ad6-41ca-a14a-f384ba246662" class="bulleted-list"><li>Even for default ctors that should default initialize all members, explicitly provide a member init&#x27;n list, which should call default ctors for all user-defined type members and provide values for built-in type members.</li></ul><ul id="9edda2c7-a034-4120-8232-f12dbcb3b994" class="bulleted-list"><li>If listing out all members in member init&#x27;n list is too repetitive, then consider using a pseudo-init&#x27;n function that is called by all ctors. Note that this still ensures you don&#x27;t accidentally leave out any member.</li></ul></li></ul><ul id="cbc6252a-96ff-47f9-a813-c0e3496811bb" class="bulleted-list"><li>Initialization is not necessarily done by using <code>=</code> (copy or move construction). Things like <code>std::cin &gt;&gt;</code> also work.</li></ul><h3 id="400a68bc-b165-497c-a699-480f70bf30fc" class="">order of init&#x27;n</h3><ul id="e2a23959-9eb2-4e6f-a235-5666e14f87aa" class="bulleted-list"><li>Members of an object are init&#x27;ed in the same order as they are declared.<ul id="faa941d0-e6f2-450c-bbcf-271d57cfafa6" class="bulleted-list"><li>Different orders in the member init&#x27;n list doesn&#x27;t affect this rule. But to avoid confusion you should ensure that they are the same.</li></ul></li></ul><ul id="252d490d-dcbe-4e27-a437-9dbe8009e037" class="bulleted-list"><li><strong>Terms:</strong><ul id="6d4d4dc6-d899-4ef6-80cc-8a6fc7f8ebdf" class="bulleted-list"><li>A <em>static object</em> exists from the time it&#x27;s constructed until the end of the program.<ul id="fae4bf4e-1a6d-4757-ad96-2bad41952565" class="bulleted-list"><li>No stack or heap objects</li></ul><ul id="d8eda5b6-fa8e-477c-af9b-64670f4d5d50" class="bulleted-list"><li>global / namespace scope / <code>static</code> inside class / <code>static</code> inside functions / <code>static</code> at file scope variables are <em>static objects</em>.</li></ul><ul id="05fe58a8-8608-4d32-9934-99a53db86b09" class="bulleted-list"><li><code>static</code> variable in functions are <em>local static objects</em>. Others are <em>non-local static objects</em>.</li></ul><ul id="b416485a-b1cd-4a17-a62e-08b9c4b809eb" class="bulleted-list"><li>When the program exits (i.e. <code>main</code> returns), dtor static objects </li></ul></li></ul><ul id="747f13d9-d896-4126-9163-0c3684946f77" class="bulleted-list"><li>A <em>translation unit</em> is the code that generates a single object file, usually a single source file plus all its headers.</li></ul></li></ul><p id="a3959b54-fe15-4235-844d-980f08845beb" class="">Say we have two separately-compiled source files. Each one has some non-local static objects. Then if they reference each other <strong>across translation units</strong>, they might be using uninitialized data. Because...</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="5dc56d93-0695-483d-ad60-cbe4c40ecfcd"><div style="font-size:1.5em"><span class="icon">⚠️</span></div><div style="width:100%">The relative order of init&#x27;n of non-local static objects defined in different translation units is undefined.</div></figure><p id="e335dff2-11c7-459a-8105-ed752d1c64f6" class="">To solve this, put the static object into a function.</p><pre id="18dbe9f7-fc44-456a-ad69-7ef0e8f66456" class="code"><code>// before
extern FileSystem tfs;

// after
FileSystem&amp; tfs() {
  static FileSystem fs;
  return fs;
}</code></pre><ul id="05b73922-7d9d-456f-bdb1-1de7ee009929" class="bulleted-list"><li>Note that if a variable in a function is <code>static</code>, you can return its reference. This can be confusing as they are &quot;local&quot; static objects.</li></ul><ul id="59b955cc-27a4-40d6-887c-78c1e7037006" class="bulleted-list"><li>It&#x27;s perfect for inlining.</li></ul><ul id="d2924c96-d463-447a-8ef0-d3e1866d187a" class="bulleted-list"><li>However, it&#x27;s bad for multithreading, just like other non-<code>const</code> static objects. Try to move the static object into the master thread.</li></ul><h1 id="469a8c0b-c763-42e7-9831-9de921221cbd" class="">Ctors, Dtors and <code>operator=</code></h1><h2 id="e3cd8e5c-fe3e-4964-89f3-7d600b6dc778" class="">5 Know default behaviour</h2><p id="ccefebec-5c9a-45ec-aedf-ebe4664c17b8" class="">If nothing&#x27;s present, compiler will declare a copy ctor, a copy assgm oprt, and a dtor.</p><ul id="29419fac-e941-40a1-b834-8898c536ee2d" class="bulleted-list"><li>Only generated when there are needed (used in the rest of the program)</li></ul><ul id="6b3b8d7a-3be8-4c89-b7a7-d57e7427b1b7" class="bulleted-list"><li>All are <code>public</code> and <code>inline</code>.</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="575156b3-823e-49b7-b4cf-36c41fa38466"><div style="font-size:1.5em"><span class="icon">⚠️</span></div><div style="width:100%">If you write ctors that <strong>have parameters</strong>, the compiler won&#x27;t create a default ctor for you. However, the compiler still generates copy ctor / copy assgm oprt if missing and needed.</div></figure><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="16fafe3d-c40a-4968-aba5-e708a33c7189"><div style="font-size:1.5em"><span class="icon">⚠️</span></div><div style="width:100%">If you want to support copy assgm in a class containing a <strong>reference / </strong><strong><code>const</code></strong><strong> member</strong>, you must define the copy assgm oprt yourself.</div></figure><h2 id="3482ebb2-53f3-4c20-8e14-12e680dce4dd" class="">6 Disallow generated functions you don&#x27;t want</h2><p id="af4d1396-aeb4-4cb1-93c8-b2013ca79009" class="">Use <code>= delete</code> on copy constructors to disable copying.</p><h2 id="cc3aff8f-b717-4de6-8272-94ade9e9fdcb" class="">7 Make dtors virtual in polymorphic base classes</h2><h3 id="efc42bce-f359-404a-bf04-597b7c4ba888" class="">reason</h3><p id="86de3b96-7103-4b7b-ac01-0868a3916542" class="">UB when a derived class object is deleted through a pointer to a base class with a non-<code>virtual</code> dtor. Reason: the base class non-<code>virtual</code> dtor will not call the proper dtor in the derived class and will likely only delete a part of the object. <a href="https://www.notion.so/C-Random-bits-e4aed87017ab4640b37863403d30df52#daac8dbfcfd744b0b3c99e52a2a8b61e">See Random Bits</a>.</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="00608df6-b18c-4eb3-a3f1-582a5ee970c2"><div style="font-size:1.5em"><span class="icon">⚠️</span></div><div style="width:100%">Don&#x27;t inherit from a class that doesn&#x27;t have virtual dtors, like STL containers and <code>string</code>. Check before inherit. Compiler doesn&#x27;t enforce.</div></figure><p id="64723b60-5f17-4172-b884-233a55f7c7ee" class="">However, you shouldn&#x27;t declare every dtor virtual because</p><ul id="bfbd0622-a6fe-4f27-9a65-34a28f0eb3e3" class="bulleted-list"><li>It greatly increases the size of the object</li></ul><ul id="b6c5fa0b-8d74-4535-abdf-1b1092b929b1" class="bulleted-list"><li>It makes the object incompatible with C</li></ul><p id="72864d6c-9fb7-4fa8-9f16-d48f13a2518f" class="">Only polymorphic base classes need pure virtual ctors. If a class shouldn&#x27;t be a base class (STL containers etc.) or shouldn&#x27;t be used polymorphically (an interface/protocol), it shouldn&#x27;t have virtual destructors.</p><h3 id="9d8dbd8b-2559-4405-abf3-6484fc951697" class="">pure virtual dtors</h3><p id="b1a1b8d2-d7a7-49d7-9e2f-208e0b4ecf4c" class="">If you want a class to be an abstract class but you don&#x27;t have any pure virtual functions (i.e. you have default implementation for all virtual functions), simply <strong>define</strong> a pure virtual dtor.</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="fd8374e1-96ae-468d-9ce5-6f6bfc4ce54f"><div style="font-size:1.5em"><span class="icon">⚠️</span></div><div style="width:100%">You must supply a definition for the dtor, possibly with <code>T::~T() = default</code>.</div></figure><h2 id="30b88d52-2613-4ab5-ba8e-1c741644a483" class="">8 Prevent exceptions from leaving dtors</h2><h3 id="a654eefd-5e97-4b74-8bfb-01d873f98e0e" class="">ROT</h3><ul id="ebeee5a8-8c6a-4d19-b452-4ba78c3874f4" class="bulleted-list"><li>dtors must not emit exceptions</li></ul><ul id="9f33f298-918a-4080-b5cd-19cbb06e0a08" class="bulleted-list"><li>if func called in dtor might throw, dtor should catch and terminate/swallow</li></ul><ul id="106149fc-6e39-41fa-a256-7d41c2a0b428" class="bulleted-list"><li>empower the client to react to the exceptions</li></ul><h3 id="9e2d0ca6-fcf2-44f0-bf74-de3dcb797524" class="">reason</h3><p id="37e67d4f-9c30-4587-a83e-84083c74a7ab" class="">You may have two exceptions active. UB.</p><h3 id="d7c35b18-ad7a-45a9-b6e2-ba6c7756d555" class="">problem &amp; solutions</h3><p id="b3ea10ba-0ff2-483d-b84d-9c84ac960040" class="">It&#x27;s easy not to throw exceptions that aren&#x27;t catched, but when the dtor needs to release other resources by calling other functions, it may not be so obvious. Two ways to dogde:</p><ul id="517df0d5-0c8b-48cc-abe3-828d221c5736" class="bulleted-list"><li>Terminate the program, typically by calling <code>std::abort</code>. It stops the current dtor from propagating the exception.</li></ul><ul id="84325e10-c200-4767-83cc-66737cb65b45" class="bulleted-list"><li>Swallow the exception. Generally not a good idea, but if aborting leads to premature termination you need to swallow. Do recover.</li></ul><p id="22372d0a-c1f8-4903-b357-2b5657e12d56" class="">A better strategy that moves exception handling code out of dtors and wraps those treatments:</p><ul id="c533af7c-5071-4440-a422-35bd7dbb54ed" class="bulleted-list"><li>Lift the exception-throwing logic to another member function, exposing it to the client.</li></ul><ul id="69e9f083-577f-4674-867a-9a32f9ce1cfc" class="bulleted-list"><li>Keep track of whether the client has called that function. If not, call it in dtor.</li></ul><p id="1740fe21-5102-4c1d-995d-7ff25891cf0e" class="">This enables the client to handle the exception by themselves; if they choose not to, the default behaviour will also be safe.</p><h2 id="6a6427b9-ba98-4b3b-b79c-68d58d06a306" class="">9 Never call virtual funcs during constr&#x27;n or destr&#x27;n.</h2><h3 id="2c385769-75dc-4082-9c49-34323f05e9a6" class="">ROT</h3><p id="1a9247be-7dbd-4bab-b08d-f27f36826d04" class="">never call virtual funcs in ctor and dtor; they never go to a more derived class.</p><h3 id="c5f968d6-4a5a-47aa-a309-701d00a35b54" class="">reason</h3><p id="96cc1433-062d-4147-abaf-4e5139dbda53" class="">Say we have a base class (which has a virtual member function and whose ctor calls that function) and a derived class.</p><p id="a08672c1-6958-4f0e-844c-1b75c9578615" class="">We declare an object of the derived class. It will call the ctor of the base class, which calls that virtual func. But since it&#x27;s inside the base class&#x27;s ctor, the base class version of the virtual func is called, not the derived version. So, during base class constr&#x27;n, virtual funcs never go down to the derived classes.</p><h3 id="0d4e2f88-5072-4878-a6a6-8d5c80c1692a" class="">object type treatment model</h3><p id="31da879f-2559-415e-b52e-e5a0769e8018" class="">When constructing a derived obj, the base ctor will be called first. During that, the obj is deemed a base object by runtime type info utilities.</p><p id="a4c32606-12cb-40eb-8443-0fa27d3e25da" class="">When destructing a derived obj, the base dtor will finally be called. The extra members from the derived class should be handled by the derived dtors already at that point, so during dtor of base class, the obj is deemed a base obj.</p><h3 id="9b25875b-d53a-4c35-b30d-6f4629082c96" class="">problem &amp; solutions</h3><p id="6686b9dc-63d7-44b2-8481-0b6d2b9372c7" class="">Like <a href="https://www.notion.so/Effective-C-73e0037beb024637b5e5e08848f8d4fd#b3ea10ba0ff2483db84d9c84ac960040">Item 8</a>, it&#x27;s easy to spot direct violation but not virtual func calls in nested funcs called by c/dtors.</p><p id="bf9197fc-94cd-46ea-90e1-67f041b7569c" class="">Make the virtual func non-virtual; pass polymorphic info needed by derived classes to the ctors of the base class, to treat subclasses differently.</p><h2 id="538b438d-7fee-450a-b501-92e394bcf6a3" class="">10 Have assignment operators return a reference to <code>*this</code></h2><h3 id="6828697f-9078-4638-b3c6-5b4f7617e1e8" class="">ROT</h3><p id="7a8b2f39-a2df-4aac-9833-f50bd2e90a86" class="">This is for supporting chaining <code>=</code> operations.</p><pre id="557d7ff6-cacd-4964-9e52-ff19e745e01d" class="code"><code>Widget&amp; operator=(const Widget&amp; rhs) {
  // ...
  return *this;
}</code></pre><p id="cd7a26ec-0f63-4b78-80b2-dc9a441c68ab" class="">Also include different signatures and other assignment operators.</p><h2 id="85d399cd-10a9-457e-a0b2-73ac1d5aecc1" class="">11 Handle assignment to self in <code>operator=</code></h2><h3 id="444acb77-b97c-4a40-b1c3-93053d27db41" class="">ROT</h3><ul id="3dd567a6-4deb-4f14-8575-c2be6a2c7a36" class="bulleted-list"><li>make sure <code>operator=</code> is well-behaved even when rhs is same obj</li></ul><ul id="72c05499-fe4a-47eb-80ca-00b64475ae36" class="bulleted-list"><li>techniques: compare identity, reorder, copy-and-swap</li></ul><ul id="6ff34ea3-f50d-41c7-84aa-ad111657d319" class="bulleted-list"><li>make sure any function operating on two objs or more work well even when some of the parameters are the same obj</li></ul><h3 id="b22ad7dc-d474-46d8-a7df-4375e26731c6" class="">problem</h3><p id="1b029a31-c13c-4c11-859c-7fac4810bca6" class="">Sometimes client will assign an object to itself, explicitly or implicitly, i.e. <code>obj = obj</code>. When that happens, the <code>operator=</code>&#x27;s rhs is the same object as <code>*this</code>, so normal logic that assumes lhs ≠ rhs can be disaster.</p><h3 id="59d5af37-592f-4460-812f-bda1f9366d13" class="">solutions</h3><ul id="a216e2d7-2b5d-4e46-a9d8-7d6fdb306b71" class="bulleted-list"><li>Add a guard: <code>if (this == &amp;rhs) return *this;</code><ul id="2a23a860-df8d-4e2c-a6de-f2cb318c0cd0" class="bulleted-list"><li>This is straightforward but it adds a test to every assignment</li></ul></li></ul><ul id="92001016-677f-4b63-ae4a-205fdae6b5ba" class="bulleted-list"><li>Aim to make the <code>operator=</code> exception-safe.<ul id="5972c2c2-912e-4522-860a-bd63724c2dca" class="bulleted-list"><li>e.g. don&#x27;t <code>delete</code> the original member before you&#x27;re sure the <code>new</code>ed member works</li></ul><ul id="2657d164-4d05-471d-b628-42bb5a438f3f" class="bulleted-list"><li>imagine if rhs is the obj itself and see what could go wrong</li></ul></li></ul><ul id="6bae9f47-dcef-4f85-9b39-8cfb46abbe78" class="bulleted-list"><li>Use the &quot;copy and swap&quot; technique<ul id="b0877528-ae1c-4db6-a3b8-973ef8addf4d" class="bulleted-list"><li>define a <code>swap</code> function for the class</li></ul><ul id="2b155e37-2dad-4905-96ff-55d90345ea11" class="bulleted-list"><li>in <code>operator=</code> implementation, copy-construct a new object, swap, and <code>return *this;</code><ul id="d7b3ba70-3155-4b58-8522-bbd7fdb091db" class="bulleted-list"><li>alternatively, use the naked type as the type of rhs (which triggers copy constr&#x27;n) and just swap. Might be better for optimization</li></ul></li></ul></li></ul><h2 id="cb4c32e4-25ae-4733-8ff2-9d2e42b67ed8" class="">12 Copy all parts of an object</h2><h3 id="f32adfe5-25dc-4713-948f-55c0c850bb4b" class="">ROT</h3><ul id="346f9091-c473-4fea-b60a-a0b54b5b534d" class="bulleted-list"><li>copy functions must copy all of an obj&#x27;s data members and all of its base class parts</li></ul><ul id="5dff1d2d-d71b-42bc-8641-4a7d6ed34471" class="bulleted-list"><li>don&#x27;t implement one of the copying functions in terms the other<ul id="a04ae962-4994-42e7-8e61-0a82e6e01716" class="bulleted-list"><li>use 3rd func that both call</li></ul></li></ul><h3 id="a95f3772-8f94-414a-b1ca-3746d5e247c9" class="">potential partial init&#x27;n</h3><p id="19a445a9-6595-4c3d-9e7a-4de1577199f5" class="">The compiler-generated default copy ctors and copy assignment operators will copy all members; but if you choose to write copying functions by hand, you need to make sure every member is in the member init&#x27;n list.</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="9a4f434a-613a-439d-a096-159c02ec2dfd"><div style="font-size:1.5em"><span class="icon">⚠️</span></div><div style="width:100%">When adding a new member to a class, also update all copying functions.</div></figure><h3 id="92d8a11a-ebde-45cb-a776-11a08b401ad5" class="">init&#x27;n of subclasses</h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="948c9793-24a5-4d19-a805-9335b22dae94"><div style="font-size:1.5em"><span class="icon">⚠️</span></div><div style="width:100%">Invoke base class&#x27;s copying functions in subclass&#x27;s copying functions</div></figure><ul id="db5df9c9-c4ac-4b16-a5bf-edeef9794d01" class="bulleted-list"><li>For copy ctor, invoke <code>BaseClass(rhs)</code> in member init&#x27;n list</li></ul><ul id="24ecf10f-8c6f-4056-a20b-936eda89d3c8" class="bulleted-list"><li>For copy assignment operator, call <code>BaseClass::operator=(rhs)</code> in <code>operator=</code> implementation</li></ul><h3 id="89a674fe-c9b6-4890-8e40-a9d3b719841d" class="">boilerplate</h3><p id="6d0a78de-d554-40fc-ba7a-d146fa16ee89" class="">Extract a common func that both copying funcs call. Usually <code>private</code>, named <code>init</code>.</p><h1 id="f6c3f007-4b30-490d-b44b-0b616e0c2073" class="">Resource Management</h1><p id="927d714e-5acf-4cd7-b33e-5c636e572950" class="">Using the ad hoc way to deal with resource management is error-prone and weak to change. We need better methods.</p><h2 id="1a059705-eb30-4021-b7ca-18cbf8e22942" class="">13 Use objects to manage resources</h2><p id="8a6f0394-9332-48ef-bbd8-0b8eef7c221b" class="">We might have an obj that must release resources by <code>delete</code> or other functions when it&#x27;s done being used. Ensuring that by hand is impossible as code has branches and changes over time. Thus we wrap that obj in another obj...</p><ul id="4c31f503-025b-40ff-81bc-0169a6e6786e" class="bulleted-list"><li>whose ctor aquires all resources as part of init&#x27;n (RAII)</li></ul><ul id="396cca24-f5ff-4c78-b3f9-bacaf82db286" class="bulleted-list"><li>whose dtor will do all the releasing</li></ul><p id="493efe52-e8f4-414f-bc88-c7d9e38cb1cf" class="">You don&#x27;t have to write all resource-managing objs by yourself. If all resources you need to manage is dynamically allocated memory, use <a href="https://www.notion.so/C-Random-bits-e4aed87017ab4640b37863403d30df52#2c2deb8e4169407dad2f8d888b7fba89"><code>unique_ptr</code></a> and <a href="https://www.notion.so/C-Random-bits-e4aed87017ab4640b37863403d30df52#83edf3f44b824f728a326ab1460f7655"><code>shared_ptr</code></a>. (both them work for C-arrays)</p><h2 id="b290ada5-4527-40ef-b0a3-89cb33899bf9" class="">14 Think copying behavior in resource-managing classes</h2><p id="75956309-386c-47e9-b5bc-00762a3cc1e5" class="">You must think about when writing an RAII class: what should happen when an RAII object is copied?</p><h3 id="900cf5a2-c0f4-456d-b7a7-4500686630bb" class="">prohibit copying</h3><p id="dc5964c5-0745-46fb-8dde-4d959c28d1c1" class=""><strong>Scenario</strong>: it makes no sense to allow copying</p><p id="1abd6323-821c-42a4-9429-a14c729288b8" class="">Just prohibit it by setting the copying functions <code>= delete;</code></p><h3 id="fd7aa2d7-5e62-466b-ac95-cb7b4f130a5b" class="">reference-count the underlying resource</h3><p id="d33fd0ad-c360-465e-a257-c87051d8632d" class=""><strong>Scenario</strong>: it&#x27;s OK for multiple objects to use one resource, and you want resources to be released when the last of such objects is destroyed.</p><p id="bf130568-50f8-45e7-8ef8-5b62ea5409c6" class="">Then you must add a counter in the RAII class. Of course, when copying an RAII object, increase the counter by 1. Check for the counter when destroying.</p><p id="86d3a613-9a32-49eb-a4ef-d0e7d50c427e" class="">If you don&#x27;t want to manually write a class for the reference-counting behavior, <code>shared_ptr</code> allows custom deleter, if the resource is not just memory and can&#x27;t be simply <code>delete</code>d. Just pass the function to be called as the second param.</p><h3 id="4c65bb2f-1303-4bd5-96b1-5177fd721e95" class="">copy the underlying resource</h3><p id="904a25ab-ebd2-43e9-98ce-8843e13c47a7" class=""><strong>Scenario</strong>: you can have as many copies of a resource as you like, as long as each copy will release the resource properly.</p><p id="760a4b69-018b-411c-b15e-49ae7a06f890" class="">Then you perform a &quot;deep copy,&quot; i.e. create a new copy with everything the same. This is very common for classes that represent a slice of data, like a <code>string</code>.</p><h3 id="89aa1c39-a3f8-4710-8951-4760c2852500" class="">transfer ownership of the underlying resource</h3><p id="93685e52-961f-44b0-8a6b-0e42f077da60" class="">This is rare. You invalidate the previous obj and make the new obj usable, like <code>auto_ptr</code>.</p><h2 id="b4f36b36-5322-417f-8ffe-6bd6673ff1cc" class="">15 Provide access to raw resources in res-mng class</h2><h3 id="23db9612-59b7-4960-a7bb-7a5e19c53995" class="">ROT</h3><ul id="c6addab7-132e-479e-9aa2-b32e50ee1ebc" class="bulleted-list"><li>define funcs to get internals</li></ul><ul id="e4d503e5-b269-4657-af47-340a86fea931" class="bulleted-list"><li>think about whether to allow implicit conversion</li></ul><h3 id="ce10f4a5-b97a-420e-9849-82a2226ad888" class="">reason</h3><p id="01f6a6f1-04fe-4096-af3b-42cdf3effebe" class="">There might be cases (interaction with other APIs) where the user needs to use the wrapped resource (usually the pointer) inside an RAII class.</p><h3 id="184e0aff-4a61-4ac6-894f-8f0b27224f98" class="">in practice</h3><ul id="e368c2ea-05cb-4689-b840-ce4ab0fede9c" class="bulleted-list"><li>implement a <code>.get()</code> method that returns the internal resource</li></ul><ul id="8cff2f95-99df-4843-b5c9-48bce018c8c6" class="bulleted-list"><li>☢️DANGER: define implicit conversion operator if it&#x27;s so common</li></ul><ul id="863d3902-90ec-4378-ab8d-3fabb35c2cdb" class="bulleted-list"><li>for pointers, overload <code>-&gt;</code> and <code>*</code></li></ul><h2 id="9f2981d1-f937-4a4e-a684-da541b6c64ee" class="">16 Use matched <code>[]</code> in <code>new</code> and <code>delete</code></h2><p id="48040d0e-1ad7-4bd6-a463-ae47102d9331" class="">Wrong use leads to UB.</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="6da808b2-e334-47d4-824c-9f00bedbadaf"><div style="font-size:1.5em"><span class="icon">⚠️</span></div><div style="width:100%">Sometimes it&#x27;s hard to tell if the thing to be <code>delete</code>d is a C-array, like when the array is declared in a class or you have <code>typedef</code>ed an array into something.</div></figure><h2 id="832fef6c-2614-4529-9ef9-ee9e0495f67c" class="">17 Store <code>new</code>ed objs in smart ptrs in standalone statements</h2><h3 id="d671bed6-e5f2-43eb-a97b-ff1059062170" class="">ROT</h3><p id="6a264ce6-0843-49de-b794-a2e76c0f8089" class="">When creating a smart pointer, don&#x27;t put them in func calls.</p><h3 id="071b2621-ec21-4394-9535-c8a84e1b3788" class="">scenario</h3><p id="cf23cc7e-d044-49b3-ad29-ac331c75f992" class="">Say we have a function that takes a <code>shared_ptr</code> and an <code>int</code>. We might want to call it like this, in one line, gracefully:</p><pre id="3ed88e6f-e419-4f0b-9e81-96f26ea250e6" class="code"><code>void f(shared_ptr&lt;T&gt; spt, int i);
f(shared_ptr&lt;T&gt;(new T), g());</code></pre><p id="c692eda8-8096-4b6e-a890-529e894b350b" class="">Surprisingly, this can leak. For <code>f</code> to be called, the two arguments must be computed:</p><ul id="774b442f-cf36-46d4-bc2c-5e3f382d3ad1" class="bulleted-list"><li>Call the ctor <code>shared_ptr</code> with the <code>new</code>ed <code>T</code>.</li></ul><ul id="433050f4-8114-404e-bb61-71c3b2f60adb" class="bulleted-list"><li>Call <code>g</code>.</li></ul><p id="95c877fa-d258-40d6-9935-00c0e4e7addf" class="">The first task can be break down into two sub-tasks, and there are three things to do. Note that the compiler can do the three tasks in random order. Suppose the compiler decides this order:</p><ul id="0d4b379a-3968-4ca2-bd97-74dd00a690bf" class="bulleted-list"><li>Execute <code>new T</code>.</li></ul><ul id="14d82119-bb13-4a7f-a3d1-997393aa331b" class="bulleted-list"><li>Call <code>g</code>.</li></ul><ul id="7d25a543-e37f-4647-a0da-3b64bc46d56a" class="bulleted-list"><li>Call <code>shared_ptr</code>.</li></ul><p id="75eb0a47-81fe-472d-8d28-d25dc3a336d9" class="">Disaster will happen if the call of <code>g</code> goes wrong and throws exception. The pointer from <code>new T</code> will be lost and cause leak.</p><h3 id="cbe9c191-f209-4d80-bbf4-6143f4a46edf" class="">problem</h3><p id="e68aba69-245b-4f96-a5f6-da2f8a9f113b" class="">If an exception happens between &quot;the time after an object is <code>new</code>ed&quot; and &quot;it&#x27;s wrapped in a smart pointer&quot;, it leaks.</p><h3 id="893426b4-8a44-47d7-a49f-1fe428f6ce26" class="">solution</h3><p id="fb6fd42b-5a93-4c15-8876-ae84074000e8" class="">Extract out creation of smart pointers.</p><pre id="7f706426-3e80-403c-a3cb-445dab568cb9" class="code"><code>shared_ptr&lt;T&gt; spt(new T);
f(spt, g());</code></pre><p id="77a09373-6496-4dc7-9d60-c8b21b90aac0" class="">The <code>make_</code> funcs in later C++ might solve this problem because it won&#x27;t use <code>new</code>.</p><h1 id="07b79c8d-b80f-49e9-95a7-d686377dfb1e" class="">Designs and Declarations</h1><p id="4017920a-e155-4908-b186-4f46aedd569b" class="">Designing software is about designing interfaces. Function, class, template interfaces.</p><h2 id="3350906f-e319-408b-9986-7e10c28d3c67" class="">18 Make interfaces easy to use right and hard to use wrong.</h2><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="8727bd92-c8b3-4f0d-a109-9e92c0b23e19"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">Ideally, &quot;it does what client expects&quot; and &quot;it compiles&quot; should be equivalent.</div></figure><h3 id="ab7f83c3-ad3b-439e-a7be-89b7d0c35987" class="">ROT</h3><p id="387fcf7f-c378-4fde-b9b2-1ba6f7cd3d19" class="">To facilitate correct use</p><ul id="2b0421d8-cc54-4e15-9f79-9bcea2b7b571" class="bulleted-list"><li>consistency in interfaces</li></ul><ul id="17ddb52d-d17b-44a7-be2b-09e67e9a38da" class="bulleted-list"><li>behavioral compatibility with built-in types</li></ul><p id="247e4b02-485a-492c-8d91-b6a95822b77d" class="">To reduce errors</p><ul id="cc592785-dad9-4989-99f5-7f522c6f9655" class="bulleted-list"><li>create new types</li></ul><ul id="b743c654-5ec2-4681-ad62-8270a38ea7b7" class="bulleted-list"><li>restrict operations on types</li></ul><ul id="78db380e-a04b-4148-97ab-6a094691972d" class="bulleted-list"><li>constrain obj values</li></ul><ul id="c0bc18bf-20b1-489d-8e97-d11cfcbc97cc" class="bulleted-list"><li>eliminate client-side res-mng responsibilities</li></ul><h3 id="4d50c5b5-e13e-4883-be68-f4decffe8cb5" class="">anticipate mistakes</h3><p id="9f38083e-c823-4b62-b3b4-e41c086a2f1f" class="">This requires you to think about what mistakes the client can make. If you want to stop the mistakes at compile time, you may turn to the type system.</p><p id="ecd86bf4-203d-4587-b554-6975288571c9" class="">Like for preventing inputting invalid dates represented by <code>int</code>s, make separate classes for Day, Month and Time, and enforce checking.</p><h3 id="f0f273a5-2ddf-4206-87bb-c6881c45e777" class="">establish consistency among built-in types and other similar types</h3><p id="59f69adc-1bfb-45a5-a90f-bb951517f573" class="">...because clients know how built-in types behave, and if they learned one thing, there&#x27;s less friction to use the other thing correctly.</p><h3 id="3f08140a-2410-4e3d-ab00-b0ddaf6ed42a" class="">reduce things that the client needs to remember</h3><p id="50b237cd-0ef2-4e35-93be-c2b5a93d7602" class="">Especially returning raw pointers. Use smart pointers with a custom deleter <a href="https://www.notion.so/nerrons/Effective-C-73e0037beb024637b5e5e08848f8d4fd#86d3a6139a3249eba4efd0e7d50c427e">(#14</a>).</p><h2 id="9fba3050-2173-4c26-b46e-8467c219dcd4" class="">19 Treat class design as type design</h2><p id="0e7f1a8d-133d-4f63-ac1d-2821faa3a5e1" class="">You need to understand the issues you face that led you to thinking about building a new class.</p><ul id="c2e3388f-962f-40cd-a50f-2c978d6b4026" class="bulleted-list"><li>How to create and destroy?<ul id="f320d404-ee8b-4f00-bfd6-592c629cfe3d" class="bulleted-list"><li>Affects ctor, dtor, memory alloc and dealloc funcs.</li></ul></li></ul><ul id="9a8c4663-6f97-4c78-9755-b2bf4593cc69" class="bulleted-list"><li>How should init&#x27;n be different from assignment?<ul id="7a038917-3abf-427c-9ba9-93f563cedaf8" class="bulleted-list"><li>They should be different as they correspond to different func calls.</li></ul></li></ul><ul id="bfd993de-f857-42f2-8d81-c25398a9df8b" class="bulleted-list"><li>What does it mean for the obj to be passed by value?<ul id="5c5da928-734b-4377-9d03-e3de52d813f7" class="bulleted-list"><li>Affects copy/move constructors.</li></ul></li></ul><ul id="d50e19d3-b09e-445c-8174-8214191ec16b" class="bulleted-list"><li>What are restrictions on legal values?<ul id="ea2bae66-7ef7-41fe-846f-cc4de3edc279" class="bulleted-list"><li>Only some combinations of values for a class&#x27;s data members are valid</li></ul><ul id="5b649780-9d66-478e-8a97-258afef2550a" class="bulleted-list"><li>This imposes invariants of the class, which must be maintained</li></ul><ul id="70bc6ca5-2395-42d7-b230-640e56919711" class="bulleted-list"><li>Affects ctors, assgmt oprts, setter funcs, exceptions to throw</li></ul></li></ul><ul id="53cf6296-69b0-4b1d-b0e4-9fe18ad30a14" class="bulleted-list"><li>Does the new type fit into an inheritance graph?<ul id="d345e179-3795-4ba8-bcba-091d735e18f4" class="bulleted-list"><li>If it inherits, your whole design is constrained by that class.</li></ul></li></ul><ul id="be55ec04-b2b6-401d-9836-307f15aa8109" class="bulleted-list"><li>What type conversions are allowed?<ul id="483a4abe-1b13-4356-81a9-ae1e683095ed" class="bulleted-list"><li>If want explicit only, write funcs to perform the conversions and use <code>explicit</code> on one param ctors</li></ul><ul id="5432819c-be30-42b7-9f84-84ff1f7b4186" class="bulleted-list"><li>If want implicit, you need to write type conversion funcs/oprts</li></ul></li></ul><ul id="3af5bd73-cd66-4f50-a267-28146157703a" class="bulleted-list"><li>What default funcs should be prohibited?<ul id="c77bff24-5338-4e8a-884e-fa09f912f20e" class="bulleted-list"><li>Use <code>= delete;</code> on ctors you don&#x27;t want, etc.</li></ul></li></ul><ul id="df7c2c86-3a56-406a-ae37-0be8644e2cae" class="bulleted-list"><li>Who should have access?<ul id="3ab08cf9-aca6-4974-bdad-db93bb27e2b6" class="bulleted-list"><li>Affects what are public, what are private, friends, and class nesting.</li></ul></li></ul><ul id="f58e0bf4-7f16-42d2-ad82-4ba78d7ca3a5" class="bulleted-list"><li>What do this class guarantee / what&#x27;s the invisible contract?<ul id="e12fa426-5cd2-4ca5-bf90-e868b92cf4d9" class="bulleted-list"><li>Performance, exception safety, resource usage, etc.</li></ul><ul id="eb545405-1e4c-4263-bf3d-ee46177a9963" class="bulleted-list"><li>Imposes constraints on implementation.</li></ul></li></ul><ul id="6f0065bb-266d-444c-bb91-46a225f4c057" class="bulleted-list"><li>How general?<ul id="0092a4b0-889d-467e-97d0-4ecc13b899b3" class="bulleted-list"><li>Affects what goes into the class template.</li></ul></li></ul><ul id="0095de56-19d7-4faa-80d4-f3b05c068bf4" class="bulleted-list"><li>Do I really need a new class?<ul id="5f515b89-00af-48c0-b8c4-7a7edce65030" class="bulleted-list"><li>If you just want to extend a class, perhaps use non-member functions or templates.</li></ul></li></ul><h2 id="b3944e66-aaec-4c61-be73-fcbc3d9ab39a" class="">20 Prefer pass-by-ref-to-<code>const</code> to pass-by-value</h2><p id="2347a5f4-c7fe-43f0-9359-e88d533d47c9" class="">Note: we aren&#x27;t considering move semantics and other modern features here.</p><h3 id="d17a59a5-6d93-4d99-ae69-2ca2b0b38386" class="">ROT</h3><ul id="85d2e219-d1a6-4a36-9d35-c5a343aad060" class="bulleted-list"><li>it&#x27;s more efficient and avoids the slicing problem</li></ul><ul id="31697b82-ea52-4506-bb00-9ba96f6f19b0" class="bulleted-list"><li>except built-in types, STL iterator and func objs</li></ul><h3 id="f2c6a259-3b63-4ad6-bbeb-fdd87dbe3ad3" class="">reason: performance</h3><p id="f56408f9-c42d-45ef-9229-160966c43e2f" class="">Having a &quot;naked&quot; type in func param <strong>causes the copy ctor to be called</strong>, and subsequently, ctors of the members and superclasses. Also <strong>dtors will be called</strong> when the func returns.</p><p id="38cfaf65-f803-414c-9835-0a786dda8d8a" class="">Even some types might be small, <strong>copying them can still be expensive</strong>, e.g. copying an STL pointer copies everything it points to.</p><p id="7f42a58d-4bbb-4e43-acbe-5dc329c0e410" class="">Even some types might be small and their copy operations cheap, <strong>compilers may treat them differently</strong> (e.g. placing a built-in <code>double</code> in a register while refusing to do so for a mere wrapper of <code>double</code>), leading to performance problems.</p><p id="7709a511-1524-47fc-b8f2-213a0d4d8b3d" class="">Pass-by-ref-to-const avoids creating new objects and thus calling ctors and dtors.</p><h3 id="531e46c4-4b06-4115-990c-edb50bcddc18" class="">reason: slicing</h3><p id="03f72513-5913-4d84-b0f2-40c89831d479" class="">If you pass a derived class obj into a func that takes a base class obj, only the base class ctor is called and you&#x27;re left with a &quot;subset.&quot; This is particularly bad if you&#x27;re using polymorphism: the base class version of the func is called.</p><h3 id="f0045b51-e23b-43b2-9443-2fc1f606ebb8" class="">knowledge</h3><ul id="74d656e9-963d-40eb-9d70-0349782945d4" class="bulleted-list"><li>References are typically implemented as pointers, so they are cheap.</li></ul><ul id="a99115e9-40c2-45d2-aa81-4d96c5d8142e" class="bulleted-list"><li>You can pass-by-value <strong>built-in types</strong>, STL <strong>iterator</strong> and <strong>func objs </strong>because they&#x27;re designed to behave when being copied. Aim for the same.</li></ul><h2 id="d5e97720-b03a-42f3-9672-b55760860a1b" class="">21 Don&#x27;t return ref to local obj when returning an obj</h2><p id="5204d650-b241-4ad2-9ac2-1fadd87e1074" class="">Note: we aren&#x27;t considering move semantics and other modern features here.</p><h3 id="6fe62330-1f56-4fa5-9e77-3528e16c6e8f" class="">ROT</h3><ul id="8eb152ec-c711-4177-ad80-2e8e8807f8bf" class="bulleted-list"><li>never return<ul id="7e44fba0-8633-42ac-ae8b-e021fb59c95b" class="bulleted-list"><li>ptr or ref to local stack obj</li></ul><ul id="66c1014d-08c6-4049-aaf5-a986d2e8f4b3" class="bulleted-list"><li>ptr or ref to static obj</li></ul><ul id="f4a5c0ef-deca-42ba-be27-fae22c6265b4" class="bulleted-list"><li>ref to heap obj (ptr is very occasionally ok if it&#x27;s managed by another env)</li></ul></li></ul><h3 id="4b1cc0c2-e71b-4203-9a6e-0ae5b1ec227b" class="">reason</h3><p id="182e1991-6ed4-47d6-8171-c2a2336c6874" class="">And, it doesn&#x27;t bring any performance benifits. Consider:</p><ul id="918e92f0-4176-4fcc-8c24-bfe5fb0c6b0f" class="bulleted-list"><li>If a func wants to return a reference, that reference must point to an existing obj.</li></ul><ul id="2659572e-16ed-42d4-9aa4-a4d971c985dd" class="bulleted-list"><li>In a function, an obj can either be on the stack or the heap.</li></ul><ul id="6ad6d53e-a023-40e0-8166-5ae7681bd10a" class="bulleted-list"><li>You either define a local obj or <code>new</code> one.<ul id="33815336-fab5-4b9d-9b79-fed604931fe1" class="bulleted-list"><li>Local objects are allocated on the stack and will be destroyed when the func returns. If you return a reference to such object (which doesn&#x27;t exist any more), you get UB.</li></ul><ul id="f3c3d7e9-879c-4686-9687-ed0d733f1cd0" class="bulleted-list"><li>Using <code>new</code> is very bad because users have to <code>delete</code> and sometimes there&#x27;s no way to <code>delete</code> at all.</li></ul><ul id="9d03a76c-4a23-45d9-be84-975e65048b12" class="bulleted-list"><li>Either way, you call the ctor and must call the dtor.</li></ul></li></ul><h2 id="2f919d64-6fab-4686-988e-0327fcf5d404" class="">22 Declare data members <code>private</code></h2><h3 id="01dddd4c-924f-4e3d-b67c-16e2af0e47af" class="">reason aginst <code>public</code></h3><ul id="c7687311-8303-4a4b-baea-681d8872b0e4" class="bulleted-list"><li><strong>Consistency</strong>: Client won&#x27;t need to remember what&#x27;s accessed through member variable or function.</li></ul><ul id="f127f696-0ae9-4483-8889-65746285bc36" class="bulleted-list"><li><strong>Finer access control</strong>: Public member is read-write access; using getter/setter can implement zero/read-only/read-write access (or ridiculously, write-only).<ul id="89e4a318-4579-466a-bc50-ba92b6a22cf8" class="bulleted-list"><li>Many data members should be hidden. Not all needs a getter/setter.</li></ul></li></ul><ul id="bf5ba2fa-01b3-4e9a-ab1c-8de4f6c28d96" class="bulleted-list"><li><strong>Encapsulation</strong>: If you have a computed property, using functions allow you to change underlying implementation without making clients to change their code.<ul id="145b344a-ef5e-4d16-9bfd-3bc11c2129b4" class="bulleted-list"><li>You can ensure the class invariant is maintained because clients can&#x27;t mess with them</li></ul></li></ul><ul id="753bd69a-7475-4a4c-8d3e-e51c8bb582cc" class="bulleted-list"><li><strong>Flexibility</strong>: You can easily extend the getting/setting action with other things you need to do before and after (like a pre-commit hook in git)</li></ul><h3 id="1adb1be4-68a0-4d41-8175-0d2ec9b016b2" class="">reason against <code>protected</code></h3><p id="fc1d3ba8-ebb9-4dc1-bbba-623a95ff39aa" class="">Think about encapsulatednessof a data member (inversely proportional to the amount of code breaking when it&#x27;s changed). If it&#x27;s public, when it changes, it breaks all client code that uses it. If it&#x27;s protected, when it changes, it breaks all derived class code that uses it.</p><h2 id="a89b6b79-2ab2-4ad3-84da-3166e1cc2e3c" class="">23 Prefer non-member non-friend funcs to member funcs</h2><h3 id="a1e3dc2e-7120-46a3-97f0-f68156ab2412" class="">ROT</h3><ul id="9ff161ed-e76a-4b81-afd9-5995face8515" class="bulleted-list"><li>encapsulation, packaging flexibility, functional extensibility</li></ul><h3 id="c9b7f947-707e-4543-9d05-5f4987dfbcfe" class="">scenario</h3><p id="3fe00ccd-a06a-4e1c-8f4f-5f40c0ef6a69" class="">We have a func that simply calls other member funcs. Do we also make that a member func, or do we make it a non-member non-friend func accepting one param?</p><h3 id="cc157b02-4ed3-471a-b685-29c6091e3d39" class="">encapsulation</h3><p id="666bd822-de64-4eba-aa29-39a2e7816277" class="">Encapsulation is not solely about abstraction; its ultamate goal is to minimize exposure so it can be changed effortlessly. Making another member func adds to the number of &quot;things&quot; that can access the private members. If that is not necessary, don&#x27;t make it a member.</p><p id="72381900-fee6-457c-befc-86ce43a165c9" class="">Another benefit is that changing that outlying func doesn&#x27;t require recompiling the whole class.</p><p id="9f6e3f38-51a2-45c9-aa7b-cf955fef5a52" class="">Note that the &quot;member&quot; we&#x27;re talking about here is wrt the class the func can be written in. It can be the member of another class, which won&#x27;t affect the encapsulation of the main class in concern.</p><h3 id="aa58f01a-cf8b-4e82-baed-2ba9176bf0d4" class="">in practice</h3><p id="412d37da-2d1f-470b-ad7f-ebcbbd5d2779" class="">You can simply put the func in the same namespace as the class.</p><ul id="c0b0bf95-3540-46be-8acf-943faf0cb49f" class="bulleted-list"><li>It expresses the meaning naturally and signifies that it&#x27;s a non-mem non-fren func (a conveniece func).</li></ul><ul id="7b1c14f1-967b-4448-aa34-3bafa3deff2c" class="bulleted-list"><li>Namespaces can span across multiple files, so if you have a lot of convenience funcs, you can put them in different headers for better modularity.<ul id="b650cbcc-d7b2-4cfd-9e07-5d8b8ae314b4" class="bulleted-list"><li>Note that you have many STL headers but all of them are in <code>std::</code></li></ul></li></ul><ul id="d4206185-ae7f-4a9e-b356-f7dce029b6de" class="bulleted-list"><li>Clients can easily extend the set of conv funcs.</li></ul><h2 id="f6865af8-8753-461c-9353-2e6dc93ce666" class="">24 Declare non-member funcs when type conversions should apply to all params</h2><p id="17c3e068-ce47-42ef-9ee6-bbff215a37bf" class="">This is especially true for numerical classes. If the operator a member function, the first param must be under this class, i.e. type conversion won&#x27;t work on the first param.</p><p id="72e1e2a3-5ecf-4d66-870a-b52cfe61169a" class="">If you don&#x27;t need access to the internals, you don&#x27;t need the operator to be <code>friend</code>.</p><h2 id="c69f04ad-acf3-4ce7-8de0-1bce5fad6a21" class="">25 Consider support for non-throwing <code>swap</code></h2><h3 id="c39c2a61-22c3-4a06-a809-b88d174fd84b" class="">background</h3><p id="e1464bec-dddf-44dd-94c3-265800e4ffe8" class="">You may want to implement your own <code>swap</code>. <code>std::swap</code> might be too heavy because it calls copy ctor 3 times. If you have a pimpl class, <code>std::swap</code> will still copy their underlying data, while actually only the pointers need to be swapped.</p><h3 id="e9b6e634-736d-4b3f-bdc4-590be2d9c320" class=""><code>std::swap</code> with a member <code>swap</code></h3><p id="c91cbc94-3349-4464-b90e-df5a82aff1d2" class="">We try to extend the <code>std::swap</code> with a <em>total template specialization</em> for when <code>T</code> is a <code>Widget</code>, but we can&#x27;t directly access the underlying pimpl because it&#x27;s private. Thus, we provide a <code>Widget::swap</code> to be called by the <code>std::swap&lt;Widget&gt;</code>. This is simple encapsulation.</p><pre id="64efaa40-0f2c-40dd-8380-d6e52d1afa0b" class="code"><code>class Widget {
public:
	void swap(Widget&amp; other) {
		using std::swap; // explained later <a href="https://www.notion.so/nerrons/Effective-C-73e0037beb024637b5e5e08848f8d4fd#ba98de57cc66491684fc79fd3a705225">here</a>
		swap(pImpl, other.pImpl);
	}
};
namespace std {
	template&lt;&gt; // marks total template specialization
	void swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)
	{ a.swap(b); }
}</code></pre><h3 id="16b56dcd-9dad-495f-a10c-7d69cd152ff9" class="">when it&#x27;s a class template</h3><p id="0b7459e0-b276-404c-bdf7-5dabdc2344e3" class="">If <code>Widget</code> is a class template that takes a typename <code>T</code>, the template specialization for <code>swap</code> fails (because funcs can&#x27;t do <em>partial</em>). We just overload:</p><pre id="b0d65a02-2ae2-451a-9c77-73f32cb6ef17" class="code"><code>template&lt;typename T&gt;
void swap(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b) // No angle brackets
{ a.swap(b); }</code></pre><p id="dbb924e9-e530-4eb3-bd00-b67af50c4267" class="">But the <code>std</code> namespace is protected so you can&#x27;t just <em>add</em> another function with a <em>new</em> signature. So we put that func in our custom namespace:</p><pre id="bba1496d-d95b-4f2c-a06d-4a9e75ad3b02" class="code"><code>namespace WidgetStuff {
	template&lt;typename T&gt; class Widget { /* ... */ }
	template&lt;typename T&gt; void swap(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)
	{ a.swap(b); }
}</code></pre><p id="13ad9795-222d-4964-8f59-53aef9fbdf46" class="">Then if the user calls <code>swap</code> on two <code>Widget</code> objects, the <em>argument-dependent lookup </em>or <em>Koenig lookup</em> finds this <code>Widget</code>-specific version in <code>WidgetStuff</code>. Of course, even if your class is not a class template, you can also write a non-member swap like this.</p><h3 id="ba98de57-cc66-4916-84fc-79fd3a705225" class="">making it easy for the clients to call the correct version</h3><p id="010e0f29-82a7-4696-b167-43de8ec09882" class="">Now we have three versions of <code>swap</code>, ranked from the least to the most desired:</p><ul id="924b50c5-62b3-4b48-a25d-a75a6d6e5260" class="bulleted-list"><li>good o&#x27; <code>std::swap</code> (must exist)</li></ul><ul id="314c0ead-0be2-4436-a24b-710d4a6b8ff1" class="bulleted-list"><li>specialized <code>std::swap</code> (may or may not exist)</li></ul><ul id="da5ee512-45b6-4872-b047-06d6e0d16e41" class="bulleted-list"><li><code>T</code>-specific <code>swap</code> (may or may not exist, and may or may not be in a namespace)</li></ul><p id="f0cfbbb7-0eed-40dc-b2ab-b638ec8c2ed2" class="">The client wants to simply call a <code>swap</code> and let the compiler design whether to call the more specific versions or fall back to the general <code>std::swap</code>.</p><p id="9db7aa9c-9807-4687-8bd2-e20ea6282f4a" class="">To ensure this fall back behaviour, the client must have <code>std::swap</code> available when a <code>swap</code> is called. simply putting a <code>using std::swap;</code>before the <code>swap</code> call will suffice.</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="d8b5969d-2daf-4c3a-a3b3-1bf2fd0c78fc"><div style="font-size:1.5em"><span class="icon">⚠️</span></div><div style="width:100%">Don&#x27;t qualify with an <code>std::</code> in front.</div></figure><p id="c4cfea70-9edd-4706-86a3-d1bdcae0c43c" class="">This is also why we need to follow the <code>using std::swap;</code> rule even inside the member <code>swap</code>: without it, it can only resolve to the <code>T</code>-specific <code>swap</code>, which might not be defined.</p><h3 id="e92554ea-a02b-43ad-b2f9-ba12923b3c45" class="">recipe</h3><p id="bf66c32b-c58f-4cdd-a6c8-fad4cde7ea20" class="">(If default <code>swap</code> is acceptable, don&#x27;t mess around like this. Else:)</p><ul id="b495a7f8-5b51-4099-8f27-888a5687bf00" class="bulleted-list"><li>Offer public member <code>swap</code> func that efficiently swaps the value of two objects of your type (while, of course, maintaining the identity). Prevent emitting exceptions using <code>noexcept</code>.</li></ul><ul id="3bcafb17-cd55-4abb-89d9-c1cf8a45fe55" class="bulleted-list"><li>Offer non-member, same-namespace <code>swap</code> that calls member <code>swap</code>.</li></ul><ul id="d335e92f-b0d9-4483-8272-d2b041cb4ed8" class="bulleted-list"><li>If not class template, specialize <code>std::swap</code> for your class that calls member <code>swap</code>.</li></ul><p id="a55a7c22-c7f6-4c46-9002-4e3973bebc23" class="">Finally, when you call <code>swap</code>, precede with <code>using std::swap;</code> and never qualify.</p><h1 id="e5f26973-5abc-4e8e-b4b1-ca7f6392e180" class="">Implementations</h1><p id="be341932-5d0d-47be-8699-4810d0e927bf" class="">This chapter is about writing definitions of things. Do make declaration and design good though.</p><h2 id="e08e6a0d-b999-466d-a228-78120b58d3ea" class="">26 Postpone variable definitions as long as possible</h2><ul id="a0800d6e-c19a-4f79-87ba-ee00097ef426" class="bulleted-list"><li>We shouldn&#x27;t define unused variables. It&#x27;s easy to avoid totally unused variables but not so for the &quot;partially&quot; unused in some branches.</li></ul><ul id="2f8c1f25-0563-4d1e-ae0c-5169a70dd6d0" class="bulleted-list"><li>Also don&#x27;t define a variable until you have a value to initialize it. This avoids calling the default ctor.</li></ul><ul id="18ce947d-49d7-4c17-9410-3bfaa18f70ff" class="bulleted-list"><li>Define variables insed the loop by default (clearer and doesn&#x27;t pollute), unless assignment is cheaper than constr&#x27;n/destr&#x27;n.</li></ul><h2 id="37f362cc-ca63-4309-908a-f2c1fddf5579" class="">27 Minimize casting</h2><h3 id="dbabe823-8fef-4af6-a601-1d256454a0dd" class="">ROT</h3><ul id="059b315b-8d9e-4528-8ad2-7b60fd22d010" class="bulleted-list"><li>Casting harmful to the static typing system.</li></ul><ul id="06c63fc7-71c3-49a0-a379-417a0d519b8c" class="bulleted-list"><li>If you have to, hide the cast in a function to save clients from casting themselves.</li></ul><ul id="5989a618-f17a-4b3b-8bbc-90d7cacbdaf7" class="bulleted-list"><li>Use new-style casts.</li></ul><h3 id="1c345d70-7434-4ac6-bc04-e2e61e095ff5" class="">new-style casts</h3><ul id="d486d24a-d660-4b6c-8cf3-8e9df85948a1" class="bulleted-list"><li><code>const_cast</code>: rip off the constness of the object.</li></ul><ul id="96859105-3a70-4e0a-8657-f190c1fe1e12" class="bulleted-list"><li><code>dynamic_cast</code>: perform &quot;safe downcasting,&quot; i.e. to determine whether an object is of a particular type in an inheritance hierarchy.<ul id="0eb3aa45-d09c-4184-9ee0-53a16bb531ee" class="bulleted-list"><li>cannot be performed using the old-style syntax.</li></ul><ul id="21f32a31-a8b4-4c3b-ae16-b80571c83325" class="bulleted-list"><li>significant runtime cost</li></ul></li></ul><ul id="597f3618-53c8-4bf8-9d16-0721b6ff4937" class="bulleted-list"><li><code>reinterpret_cast</code>: for low-level casts that yield implementation-dependent results.<ul id="d07a5ee1-5e82-4b04-8bd9-b89fed68ab06" class="bulleted-list"><li>should be rare outside of low-level code</li></ul></li></ul><ul id="0aeb9171-8cd6-428d-824f-b5c6533905bb" class="bulleted-list"><li><code>static_cast</code>: force implicit conversions or reverse such conversions.<ul id="3ec86812-fbbb-4c75-a3a7-9e99bfdf1c19" class="bulleted-list"><li>non-<code>const</code> to <code>const</code>, <code>int</code> to <code>double</code></li></ul><ul id="a807003f-2871-4019-a241-ae2485b576ff" class="bulleted-list"><li><code>void*</code> to <code>T*</code>, <code>Base*</code> to <code>Derived*</code></li></ul></li></ul><p id="79703d7d-ffee-4564-b33e-2a434520827e" class="">Prefer new-style casts at all time.</p><h3 id="5051edeb-afbb-4c9e-84db-ac02f861f1e3" class="">type conversions modify values</h3><p id="7caa49df-637c-4235-8801-494495d2b61b" class="">Type conversions (implicit or explicit) usually are not only &quot;treating bits differently,&quot; they often have runtime costs. Example:</p><pre id="e3b11c88-830e-4cdd-8929-181760c3fd56" class="code"><code>Derived d;
Base* pb = &amp;d; // implicitly convert Derived* to Base*</code></pre><p id="faa9d1d8-9db0-44bb-8472-03d00a85b91e" class="">The values of <code>&amp;d</code> and <code>pb</code> are not necessarily the same. One object can have more than one addresses when being pointed to by different types of pointers!</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="c8512347-46ba-449a-b53f-b20c585fa43a"><div style="font-size:1.5em"><span class="icon">⚠️</span></div><div style="width:100%">Don&#x27;t perform casts with wrong assumptions. Things can be different among compilers!</div></figure><h3 id="58740005-3311-4f8d-9533-712cb8d8498e" class=""><code>static_cast</code> might make a copy</h3><p id="7bdc9de7-f9a0-44a0-9a6b-38bd476a2dd1" class="">One common problem is calling the base virtual func in the derived overriding func&#x27;s impl&#x27;n. If you do a cast on <code>*this</code>, you actually create a base class copy instead of treating <code>*this</code> differently:</p><pre id="397b5ef6-d4fd-401a-aa83-b8932cba396f" class="code"><code>class Base {
public:
	virtual void f() { /* Base impl&#x27;n... */ }
};
class Derived : public Base {
public:
	virtual void f() {
		// How do I call the base f() here?
	}
};</code></pre><p id="fc608e99-4529-4b5e-912a-ac0757f72909" class="">You might be tempted to write:</p><pre id="06355c09-2ecb-4034-83ad-30181c487638" class="code"><code>/* !!! WRONG !!! */
static_cast&lt;Base&gt;(*this).f();
/* Derived-specific operations... */</code></pre><p id="99bf63d6-4abb-42f7-a0b6-3ca06972b166" class="">But this will call the base <code>f()</code> on the casted <code>Base</code> copy and continue to modify <code>*this</code>, leaving <code>*this</code> in an invalid state. It should be:</p><pre id="b97a8ba4-33a6-4f4b-b7bb-9c70caca2f2e" class="code"><code>Base::f();</code></pre><h3 id="dbe246a6-d67c-499a-81a2-932ccf74612d" class="">refactoring <code>dynamic_cast</code></h3><p id="491005f0-a662-4eb7-b794-2f8b53f954e2" class="">First of all, it&#x27;s <strong>incredibly slow</strong>.</p><p id="7d42e217-e3f2-4b22-88bd-0788b4fa771b" class="">One common use case of <code>dynamic_cast</code> is: you have a pointer- or reference-to-base, but you believe that pointed-to object is actually a derived object, and you want to perform operations with that assumption.</p><p id="d01957e0-effa-4239-8f61-11cd3cb2f81d" class="">Two possible ways to solve that:</p><ul id="da6d6060-be1d-4b49-b689-42c8244f80d7" class="bulleted-list"><li>Just use pointer- or reference-to-derived!</li></ul><ul id="4cff13bb-814c-4352-84bb-764118a4a322" class="bulleted-list"><li>Make a virtual func in the base class that by default does nothing, and override it with the operation you want to perform in the derived class. Just call the function!</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="623e8b9a-86e2-4b21-b6fc-0913c315e053"><div style="font-size:1.5em"><span class="icon">⚠️</span></div><div style="width:100%">Don&#x27;t use cascading <code>dynamic_cast</code>s. It should be virtual funcs.</div></figure><h2 id="22296d3c-d49b-451d-a45a-d227fa03acbf" class="">28 Avoid returning handles to object internals</h2><p id="db5a4512-8814-43d2-a66c-12b631ed4c75" class="">A data member of an object is only as encapsulated as the most accessible function that returns a handle to it (references, pointers, iterators, etc.). Thus, returning a handle is risky.</p><h3 id="ce8bf516-ddee-4acf-b266-90b0c3a21339" class="">scenario</h3><p id="b8b68535-7c24-4f6e-9cdd-8f9fd5edd5b7" class="">Let&#x27;s say we have a <code>const</code> <code>Rect</code> that consists of two internal <code>Point</code>s, and we have functions that access them.</p><ul id="09039a02-7548-4dbb-a16d-e539f18cf659" class="bulleted-list"><li>If we return a reference to the <code>Point</code>, we immediately violate the constness of the <code>Rect</code>. </li></ul><ul id="c994fe5d-08cf-4b7b-8269-b4272e69802b" class="bulleted-list"><li>If we return ref-to-<code>const</code> of the <code>Point</code>s, it can be bad in other ways, like <em>dangling handles</em>.</li></ul><h2 id="67ecb787-a347-4b8b-b686-4250d7127994" class="">29 Strive for exception-safe code</h2><p id="219fc6ba-13e1-4767-b167-28fb78a47e18" class="">It&#x27;s not about catching everything or not emitting anything! It&#x27;s about whether there&#x27;s corruption.</p><h3 id="2a87d7b2-d579-40eb-b587-48cab8bd951a" class="">ROT</h3><ul id="ac21305e-49c1-4119-a878-05024f260d9e" class="bulleted-list"><li>no corruption when thrown</li></ul><ul id="84fe34de-bafc-4ac4-95d8-a297c1e5e53b" class="bulleted-list"><li>try copy-and-swap</li></ul><ul id="df479019-3d73-42e3-8bec-fee6b13709e1" class="bulleted-list"><li>write exception-safe code by default, unless it needs legacy</li></ul><h3 id="49fd3467-141f-4e2c-a182-414113211b2d" class="">requirements for exception safety</h3><ul id="30a53544-458d-41fc-8196-7f6062637d91" class="bulleted-list"><li><strong>No leaked resources.</strong></li></ul><ul id="754a5545-15f8-446d-981b-c4045f179069" class="bulleted-list"><li><strong>No corrupted data structures.</strong></li></ul><h3 id="81c65167-eebd-4629-921e-58670c76baae" class="">three guarantees</h3><ul id="c0538123-928c-47c5-860f-39923b2bf822" class="bulleted-list"><li><strong>Basic guarantee:</strong><ul id="908543ad-1623-453e-974f-db8e2cd13ee2" class="bulleted-list"><li>When thrown, the program is still in a valid state, all invariants are still satisfied.</li></ul><ul id="b9824768-1417-4f7d-a936-0f8b5f1bf414" class="bulleted-list"><li>The exact state may not be predictable.</li></ul></li></ul><ul id="f5dc9240-0247-4efa-8c6d-f925df642535" class="bulleted-list"><li><strong>Strong guarantee:</strong><ul id="2a24c39b-963c-4594-8488-422ccb0bec5c" class="bulleted-list"><li>When thrown, the state of the program is unchanged.</li></ul><ul id="460c62f0-2890-4719-a371-250a298728c2" class="bulleted-list"><li>Calls to such funcs are <em>atomic</em> because they either succeed completely or do nothing.</li></ul><ul id="71143030-0e1e-4e6e-9395-03c967ead5e0" class="bulleted-list"><li>Easier to work with because only need to consider two possible outcomes</li></ul></li></ul><ul id="7303f1d6-a67f-4d72-9059-0ebe2ff6bce8" class="bulleted-list"><li><strong>No-throw guarantee:</strong><ul id="5b1a15e5-32f6-4f6f-9b14-245d3758139e" class="bulleted-list"><li>The func always does what it&#x27;s supposed to do.</li></ul><ul id="f8958670-4bca-44f7-8b4a-f3d3c5675d33" class="bulleted-list"><li>All operations on built-in types are no-throw.</li></ul></li></ul><h3 id="00143daf-5a9b-4cbd-b5d5-f0b08938a77f" class="">fine-tuning statements to improve exception safety</h3><ul id="c98211c5-c6eb-4d7a-b28a-c7ed8e006c6c" class="bulleted-list"><li>Don&#x27;t mark something done (by counter, etc.) until it is really done and didn&#x27;t throw.</li></ul><ul id="fcd64a3b-4edb-426b-9b3d-9264b666909b" class="bulleted-list"><li>Use RAII objects to deal with ctor/dtor safety.</li></ul><h3 id="caa05c3f-ffe4-4f9b-9da9-15b6abf2715a" class="">copy-and-swap</h3><p id="4876a76f-c487-4c60-a067-7baed8f2cc39" class=""><strong>Principle: </strong>Copy the object; make all needed changes on that copy; if anything goes wrong, the original copy remains unchanged; if all succeeds, swap the original and the copy.</p><p id="47e681c3-fccb-4bfe-b8d0-fa8bf58b8159" class=""><strong>Practice: </strong>Use the pimpl idiom (put all per-object data from the &quot;real&quot; object into a separate impl&#x27;n only object and give the real object a handle to that impl&#x27;n only object).</p><ul id="3715efe1-a58a-4864-9b78-e826708df3f8" class="bulleted-list"><li>You can make the impl&#x27;n object a struct because encaps&#x27;n should be done by the real object.</li></ul><h3 id="c991bcd1-08fc-45ef-be98-29e3f13d43cb" class="">not a panacea</h3><p id="3803e74c-ca1d-4729-8b17-f9a37ecaf0ac" class=""><strong>Feasibility:</strong> Copy-and-swap for the object itself seems really promising because it guarantees the operations on the object itself is all-or-nothing, but it doesn&#x27;t have power to control the side effects. When the function modifies non-local data, it&#x27;s very hard to provide a strong guarantee.</p><p id="0f15d50e-f7cd-4f78-bf61-0bda830007aa" class=""><strong>Efficiency: </strong>Copying an object is not negligible task.</p><h3 id="a8fc177d-abc6-448d-a707-e2fe7439b28f" class="">insights</h3><ul id="d4461ad0-015b-4252-a908-fb04961703ec" class="bulleted-list"><li>Don&#x27;t be too hard on yourself for not offering strong guarantee.</li></ul><ul id="1023fe6f-9d89-4d6e-b9b8-a91ae0abd3b0" class="bulleted-list"><li>If a func is not exception-safe, any funcs that build upon it will not be exception-safe.</li></ul><ul id="5465f75a-b650-4abc-bd67-d8288ab5f976" class="bulleted-list"><li>If a single func in the whole system is not exception-safe, the whole system is not.</li></ul><h2 id="04eefa07-fd57-43eb-b724-5ba89fd9139b" class="">30 Understand inlining</h2><h3 id="06ea5863-0a4a-4373-b3b5-74099bab80a4" class="">ROT</h3><ul id="09c05e5c-d901-41bd-820c-5fef22997abc" class="bulleted-list"><li>inline code can increase size of program since it&#x27;s repetitive</li></ul><ul id="57ac0abb-7704-4adb-a643-fc53caf72a33" class="bulleted-list"><li>limit most inlining to small, frequently called funcs</li></ul><ul id="63163d6a-58f9-4a26-b67e-65720309f55e" class="bulleted-list"><li>think debugging, binary upgradability, speed</li></ul><ul id="66f8ddb1-cf3b-4f56-8813-61d142cfb5a7" class="bulleted-list"><li>don&#x27;t declare func templates <code>inline</code> just because they&#x27;re all in header files</li></ul><h3 id="01c98fe8-20b7-4bc6-a413-fff2b2c9997d" class="">declaring an inline func</h3><ul id="1301cb88-1a26-4f2e-a164-07314aee64ea" class="bulleted-list"><li><strong>Impicitly</strong>: Just write down the func body inside the class def</li></ul><ul id="7941d4f1-3a56-4f7a-92c6-37110d591b1a" class="bulleted-list"><li><strong>Explicitly</strong>: In the impl&#x27;n file, put an <code>inline</code> keyword in front of func def</li></ul><h3 id="8bf95f38-c5b2-483b-843e-3710689e36dd" class="">inline and template</h3><p id="662325d9-9e3d-4b82-bfa3-2a697e8dc706" class="">They are independent of each other.</p><ul id="a56b7ad3-8615-42f5-b111-3ac7dec863b6" class="bulleted-list"><li>You can declare a func template <code>inline</code> if all funcs from the template should be inlined.</li></ul><ul id="60f98b03-7cce-4c17-8b6a-1ae42bdca576" class="bulleted-list"><li>If you don&#x27;t want the funcs from the template to be inlined, avoid declaring so (exp and imp).</li></ul><h3 id="3fc254e0-7251-483b-8214-8394461c068e" class="">compilers and inlines</h3><ul id="7bff0dc9-512e-4efc-90b2-f1f2c800f510" class="bulleted-list"><li>Compilers are free to refuse inlining a func</li></ul><ul id="34f0effb-21b0-4af0-b035-7a09c290267b" class="bulleted-list"><li>Even if compiler is willing to inline a func, it might or might not actually get inlined due to different ways of calling it (direct vs. through func ptr)</li></ul><ul id="c51cab4d-44db-48e2-9c94-81cfc75b5701" class="bulleted-list"><li>If you distribute binaries of your func...<ul id="bf1a5ee1-ce3c-4571-8a15-a86b77c45146" class="bulleted-list"><li>...and it&#x27;s inlined, when you update the func and the binary, your clients must recompile everything that uses that func.</li></ul><ul id="139244f8-e56f-49c7-a551-488f6fbf1c92" class="bulleted-list"><li>...and it&#x27;s not inlined, the client only needs to relink.</li></ul></li></ul><ul id="00104283-9c54-4e70-88a9-158f3ac5b4c2" class="bulleted-list"><li>Debuggers often have troubles with inline funcs. Many just disable inlining for debug builds</li></ul><h2 id="18869f2b-4779-4b4f-8cb9-4fc711b709f8" class="">31 Minimize compilation dependencies between files</h2><h3 id="0919e9ff-55fc-443f-a21e-08c07f98e5a8" class="">problem</h3><p id="f88d2f1e-e475-4319-baeb-7f47d1744449" class="">When you write a library, you have an interface and corresponding impl&#x27;n. When you change something the impl&#x27;n, you don&#x27;t want the client to recompile everything related to that &quot;something.&quot; You only want to allow recompilation when the interface changes.</p><h3 id="bb8f6d0e-7763-470a-9d6a-3af5ae0f40d1" class="">dependency chain</h3><p id="767ffba1-931c-45ab-ad64-d73686f14906" class="">If you <code>#include</code> a header that has classes that your class <code>T</code>  needs, when that header changes, the file containing <code>T</code> needs to be recompiled. Worse, this process is recursive, thus a chain.</p><p id="fcc52f75-a5d5-4e24-b612-fbf98307952a" class="">You don&#x27;t want recomp&#x27;n on impl&#x27;n change, you need to break the chain using forward declaration. </p><p id="2bacf6b0-2853-4492-af9e-f06b1c41ceed" class="">C++ doesn’t do a very good job of separating interfaces from implementations. You have to manually simulate an interface: a promise to the compiler that something can be used.</p><h3 id="d08a2e85-9be2-467f-ad0b-6729f8f7f257" class="">essence</h3><p id="79385964-9a56-42b8-a0c3-56b90e6e95d8" class="">The essence: replace dependencies of definitions with dependencies on declarations.</p><p id="e29b4efa-be3c-4eeb-972c-0f081034d217" class="">To achieve such separation, make your header files self-sufficient when practical, and when it&#x27;s not, depend on declarations in other files, not definitions.</p><h3 id="56a00920-2b0c-4e1e-8e79-67587afb604b" class="">handle class (pimpl idiom)</h3><ul id="58c9d1ab-db13-416a-807f-61b6e95c216d" class="bulleted-list"><li>Put all impl&#x27;n details into an impl&#x27;n class; <code>#include</code> it in your Handle class&#x27;s file; forward all calls to your Handle class to the impl&#x27;n class. This way you don&#x27;t even break clients&#x27; code.</li></ul><ul id="0b6179a1-f679-4457-a05e-4c358cc1a6d3" class="bulleted-list"><li>The goal of a Handle class is to break the chain between Handle class and Impl&#x27;n class.<ul id="6034200c-14be-4bb1-80fe-0f9ec98db16e" class="bulleted-list"><li>What if we try to break the dependency chain directly, by forward-declaring all the dependencies of your good o&#x27; monolithic class?<ul id="0412e6e7-d0d7-468d-bbac-a3ed114c864e" class="bulleted-list"><li>There will be too many things that can&#x27;t or is very difficult to be forward-declared.</li></ul></li></ul><ul id="fe1cd668-7b95-4fa4-9efa-31a2b11a8261" class="bulleted-list"><li>If we use the pimpl idiom, in the header file of the Handle class, the Impl&#x27;n class is easily and cleanly forward-declared.<ul id="12d48e0b-3baf-4207-a7ac-26d896d49eb3" class="bulleted-list"><li>For example, inside the Impl&#x27;n class, you can <code>#include</code> whatever you like.</li></ul></li></ul></li></ul><ul id="d2e5c921-4a43-431a-9dd5-019426b65b72" class="bulleted-list"><li>But we still have to provide an impl&#x27;n for the Handle class itself, after all.<ul id="7e7039e8-d3f3-473f-84b6-9a7683da1d4c" class="bulleted-list"><li>In the <code>.cpp</code> file, it&#x27;s true that we must include both headers. But remember it&#x27;s different from using <code>#include</code> in the <code>.h</code> file, like the monolithic class does!</li></ul><ul id="08170e39-61a5-48ce-ae7e-883a02c04275" class="bulleted-list"><li>Just init the ptr to the Impl&#x27;n class forward all member funcs to it as well.</li></ul></li></ul><ul id="eeb67ac3-1f00-471e-96ac-3e453904e3e9" class="bulleted-list"><li>Cost:<ul id="486930b9-d807-4df6-a1e7-54eea7dd4c10" class="bulleted-list"><li>each object has size increased by the ptr to the Impl&#x27;n class</li></ul><ul id="5c52eb7e-a225-4003-a24c-f49b2ace245f" class="bulleted-list"><li>each call to the member functions needs to go through one redirection</li></ul><ul id="d58bc2e7-7843-4376-996d-de2570b5342a" class="bulleted-list"><li>the Impl&#x27;n class is allocated on heap so all problems with dynamic allocation is present</li></ul><ul id="cc6ce1f5-042e-4d78-a61b-98b6b600dbbf" class="bulleted-list"><li>can&#x27;t freely use inline functions</li></ul></li></ul><h3 id="7a472785-092e-469b-aaf6-a4a669f3327e" class="">advice regarding handle class</h3><ul id="0c350e95-87c8-4a30-b9b4-2693e069b7dd" class="bulleted-list"><li>Avoid directly using objects when using handles will do.</li></ul><ul id="0df749be-d596-4cff-a0de-7a11a653be61" class="bulleted-list"><li>Depend on class declarations instead of class definitions when possible.<ul id="c27c41b2-085c-49c3-8fbc-94f90419c782" class="bulleted-list"><li>See the <a href="https://www.notion.so/nerrons/C-Random-bits-e4aed87017ab4640b37863403d30df52#e879bd29355c403a92ad3d389f198657">Notes</a>.</li></ul></li></ul><ul id="38a0e5d8-c1f6-4d3c-8dc6-198d90e25a93" class="bulleted-list"><li>Provide separate header files for declarations and definitions if necessary.<ul id="10deec72-797e-447e-98d4-5fcdb735e6fd" class="bulleted-list"><li>You&#x27;ll have to invest in keeping them consistent.</li></ul></li></ul><h3 id="878a54cb-a0c4-4d94-8e81-70d6ded1668d" class="">interface class</h3><ul id="6a902e78-ee4a-490c-a574-e18d065e8f56" class="bulleted-list"><li>An Interface class typically contains no data members, no ctors, a virtual dtor and a set of pure virtual member functions.<ul id="3dac6702-0ba7-48bc-9f07-1b39fd8d1c7b" class="bulleted-list"><li>The client always uses the Interface class and should not be aware of the concrete class</li></ul></li></ul><ul id="da55769c-37b9-4b55-bec2-ccb6fa7176f1" class="bulleted-list"><li>Using an Interface class &quot;reshapes&quot; the dependency chain: the client and the concrete class both depend on the interface class, so whether the concrete class changed won&#x27;t affect client.</li></ul><ul id="469872dc-a938-413a-8816-66b3b9867348" class="bulleted-list"><li>Since clients can&#x27;t call ctors of concrete funcs, the Interface class should provide a virtual member function that acts as a ctor.<ul id="385210d3-589a-423b-a4ef-13d945e27c11" class="bulleted-list"><li>These are called factory functions and are usually static inside the Interface class</li></ul><ul id="ec1905e2-9696-4fff-ba82-bd0b2cb3b752" class="bulleted-list"><li>Insane! You can let <code>D</code> inherit <code>B</code> while a function in <code>B</code> mentions <code>D</code></li></ul></li></ul><ul id="f6444769-857f-40fb-ac89-fadc65dee8c8" class="bulleted-list"><li>Cost:<ul id="e476e41a-2326-4dd6-a4af-13523a115970" class="bulleted-list"><li>every function call is virtual</li></ul><ul id="d2133729-b600-46ac-8482-3d804de18044" class="bulleted-list"><li>objects derived from the Interface class contains a virtual table pointer</li></ul><ul id="3b685e47-370d-4cbf-89aa-4e423826adf8" class="bulleted-list"><li>can&#x27;t freely use inline functions</li></ul></li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="a8207fa5-4578-4d0f-8078-041af35f0e7f"><div style="font-size:1.5em"><span class="icon">⚠️</span></div><div style="width:100%">Interface classes are less transparent then Handle classes because clients must use ptrs or refs to access the class (because it&#x27;s virtual)</div></figure><h1 id="0d187631-a776-4696-a413-fa02b46a8460" class="">Inheritance and OOP</h1><p id="f06d633c-4089-4fac-bde3-1d70feafbb58" class="">Decisions to make:</p><ul id="092a1ba2-53ff-4230-a17f-6bb05f41f2df" class="bulleted-list"><li>inheritance, single or multiple?</li></ul><ul id="c227954f-b133-45cc-9321-0eba33dc4ad9" class="bulleted-list"><li>inheritance link, private, protected or public? virtual or non-virtual?</li></ul><ul id="c60bef2d-28e9-4a23-93ab-2148a67f0570" class="bulleted-list"><li>member function options, virtual, non-virtual or pure virtual?</li></ul><ul id="e0dacab1-d2c4-43a5-a457-fb22c50fe552" class="bulleted-list"><li>other language features (default params, lookup rules, design options, etc)</li></ul><p id="457b92b4-167c-4104-beff-288999be4483" class="">Tools provided by C++ have meanings; they are not just syntax to be followed, they express what you want to say about your software.</p><h2 id="f21376e7-376b-4689-90d1-2cb9768390bd" class="">32 Make sure public inheritance models &quot;is-a&quot;</h2><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="e2089c5b-b3f7-4fba-9df7-75cb23f19905"><div style="font-size:1.5em"><span class="icon">🔥</span></div><div style="width:100%">Public inheritance means &quot;is-a.&quot;</div></figure><h3 id="45cb4b4f-ec4f-4e15-8b54-14122ba26356" class="">semantics</h3><ul id="2b24c1a4-44ad-48cb-914a-6dec31faac2c" class="bulleted-list"><li>If class <code>D</code> inherits from class <code>B</code>, every object of type <code>D</code> is also of type <code>B</code>, but not vice versa.<ul id="b0cb57d5-05d4-441e-9107-571c57e8f671" class="bulleted-list"><li><code>B</code> is a more general concept than <code>D</code> and <code>D</code> is a more specialized concept than <code>B</code></li></ul><ul id="b97f6b97-d870-4d03-84a0-5e5f0ca47b39" class="bulleted-list"><li>Anywhere a <code>B</code> object can be used, a <code>D</code> object can be used, precisely because a <code>D</code> object is a <code>B</code> object.</li></ul><ul id="c74a5879-d124-4b02-bf8d-7beee37d0a38" class="bulleted-list"><li>Anywhere a <code>D</code> object can be used, a <code>B</code> object does not suffice, presisely because a <code>B</code> object is not a <code>D</code> object.</li></ul></li></ul><ul id="2e37a246-3933-4002-8d33-fb3268ccc8ee" class="bulleted-list"><li>The model in code does not necessarily reflect how we talk about &quot;is-a&quot; in daily language.<ul id="cc4e599f-54bc-4951-9738-a2a2d712cc3d" class="bulleted-list"><li> E.g. we say a penguin is a bird and we say a bird can fly. If we make <code>Penguin</code> publicly inherit from <code>Bird</code> then a penguin must support flying, which is wrong.<ul id="7f431c67-945f-4ca0-bae4-69f0104602e1" class="bulleted-list"><li>You shouldn&#x27;t override the <code>fly()</code> method of <code>Penguin</code> and make it throw, because calling <code>Penguin::fly()</code> will compile, and it&#x27;s semantically wrong.</li></ul></li></ul></li></ul><h3 id="dd7228c1-50df-4e2b-b6d2-8ce36dee3f2e" class="">caution</h3><ul id="15919b6e-29d4-41c5-85c1-8485b927eb8d" class="bulleted-list"><li>If <code>D</code> has more strict class invariants by <code>B</code>, the methods from <code>B</code> might break <code>D</code>.</li></ul><h2 id="9122796c-efe4-460a-a825-e6b9e2c8bd10" class="">33 Avoid hiding inherited names</h2><p id="d4799afe-8273-44b8-9526-b1974a6a4acc" class="">Naturally, names in <code>D</code>&#x27;s scope will shadow the same names in <code>B</code>&#x27;s scope.</p><h3 id="d0336f2a-d836-466d-8c0c-fcfa5c14f824" class="">hidden overloads</h3><p id="db90ba7b-a3c6-40af-9863-41e979f583a7" class="">If <code>B</code> has virtual member function overloads that is not defined in <code>D</code> (e.g. when <code>f(double)</code> and <code>f(string)</code> is defined in <code>B</code> but only <code>f(double)</code> is defined in <code>D</code>), all those overloads are hidden, so you can&#x27;t call base class overloads from derived object.</p><p id="0162aba8-0c75-4679-8f8f-719a9270e978" class="">This violates the &quot;is-a&quot; principle because now <code>D</code> is not a <code>B</code> any more (cuz it doesn&#x27;t support all functions of <code>B</code> that the client might use, which will include those overloads)</p><h3 id="615a8ccb-9518-4324-8fa2-c29d9e333d6e" class="">solution for public inheritance</h3><p id="02e40319-154a-42a6-82d6-e03c7d16b213" class="">Explicitly make base class overloads visible, by adding <code>using B::f</code> after the <code>public:</code> of <code>D</code>&#x27;s definition. This is compulsory <a href="https://www.notion.so/nerrons/Effective-C-73e0037beb024637b5e5e08848f8d4fd#0162aba80c7546798f8f719a9270e978">cuz it&#x27;s a violation otherwise</a>.</p><h3 id="80d78849-3656-4c7f-a874-1910bde18203" class="">solution for private inheritance</h3><p id="006a6e63-c78f-4eb5-888b-f58b44a0572b" class="">You don&#x27;t have to support everything provided by <code>B</code>; you can manually pick what overloads <code>D</code> should support and forward them to <code>B</code> with an inline function.</p><h2 id="9a095792-c765-4ecd-b7ae-3f99059f22de" class="">34 Differentiate between inheritance of interface and inheritance of implementation</h2><p id="0e687aa3-d714-4605-9344-48d8e347c83f" class="">This item concerns inheritance of functions.</p><p id="60e1513c-c4e4-441a-b8a6-a7b13a439127" class="">C++ inheritance is convoluted. There are three kinds of behaviours for func inht&#x27;ce:</p><ul id="a12f5ae8-297a-4b17-856e-d5f056300df4" class="bulleted-list"><li>Inherit only the interface (declaration)</li></ul><ul id="6a069b44-0eaf-41b6-9a39-be3e40e525e5" class="bulleted-list"><li>Inherit both interface and impl&#x27;n, and allow overriding</li></ul><ul id="1143c403-d76d-444a-8aff-00e8700b88fd" class="bulleted-list"><li>Inherit both interface and impl&#x27;n, but disallow overriding</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="e4d95932-f242-4322-a406-89040e6f9004"><div style="font-size:1.5em"><span class="icon">☝</span></div><div style="width:100%">The interfaces are always inherited by public inheritance.</div></figure><h3 id="a02514ff-6b06-4be7-ada3-d06589c049a1" class="">pure virtual function</h3><p id="cd232fd6-4ecc-40d7-8169-0f2b94583b88" class="">Have derived classes inherit a function <em>interface only</em>. All derived classes must supply this function but impl&#x27;n is not enforced in any way.</p><p id="c971918f-e9e0-46cf-a80e-82d4d83ee782" class="">You <strong>can </strong>supply a definition for a pure virtual function, but the only way to call it is through qualification in derived classes.</p><h3 id="bee6aac9-7a0a-4d4d-9e0d-e5842c09d7a5" class="">impure virtual function</h3><p id="47f74815-672c-4ef8-bb4e-a9b645dd91f3" class="">Have derived classes inherit a function <em>interface and a default impl&#x27;n</em>.</p><p id="788031eb-d5e0-424e-8473-0ca995f33954" class="">This might be dangerous cuz derived class can accidentally inherit the default behaviour even when it&#x27;s not explicitly specified to do so. If you want things to be on the table, you need to make the function in the base class pure virtual, and either:</p><ul id="a154e995-b931-4475-9729-9139ade96889" class="bulleted-list"><li>Provide a protected member function that acts as a default impl&#x27;n that can be used by any derived class;<ul id="193fa22f-5ca1-46b0-8ba8-c1c6289cc970" class="bulleted-list"><li>You can give the default impl&#x27;n a <code>protected</code> level at the cost of using another name;</li></ul></li></ul><ul id="387e50ad-8f4f-4fc8-9443-3db0ab375906" class="bulleted-list"><li>Or, provide a definition for that pure virtual function.<ul id="152130b5-69fd-4710-8473-a3289cb469f5" class="bulleted-list"><li>You can save the extra name but the impl&#x27;n has to be <code>public</code>. But hey, if you were still using an impure virtual function, it&#x27;s not gonna be better.</li></ul></li></ul><h3 id="18d1d3a8-ad94-41f4-9dda-6b9c00c55ccd" class="">non-virtual function</h3><p id="0c532bbf-d470-44eb-bfd4-08c1632ecd04" class="">Have derived classes inherit a function <em>interface and a mandetory impl&#x27;n</em>.</p><h3 id="b27a2a74-d3c6-469f-9880-3d7026b95965" class="">common mistakes</h3><ul id="0ce950fd-6176-4762-870d-79ab8a6ba136" class="bulleted-list"><li>Mistake #1: declare all functions non-virtual in classes that can act as base classes.<ul id="cea452f0-d469-49c9-978e-5d764175dbed" class="bulleted-list"><li>No room for specialization; Non-virtual destructors might just be wrong</li></ul><ul id="3ff2afa9-cbe5-45f5-a93f-04d57ffcae49" class="bulleted-list"><li>Arguments on performance: the 80/20 rules says that 80% of runtime is spent on 20% of code. Compared to worrying about virtual calls please do profiling and real optimization work if speed is desired.</li></ul></li></ul><ul id="13e08e10-5fec-4f65-b6e1-74eef1979ea1" class="bulleted-list"><li>Mistake #2: declare all function virtual in classes that don&#x27;t act as interfaces.<ul id="1a8e850b-b130-4783-9313-40289d71dd64" class="bulleted-list"><li>It can be a sign of a class designer who lack the backbone to take a stand.<ul id="9f60dee4-6034-4137-aa2e-522336226028" class="bulleted-list"><li>Not everything should be redefinable.</li></ul><ul id="14ce2e6e-d1de-4ed4-9e78-ebf8fd97d00a" class="bulleted-list"><li>If so, the class has no invariants, questioning the necessity of its very existence.</li></ul></li></ul></li></ul><h2 id="17dbd582-e34f-46e2-9e7a-edf76d0a8e68" class="">35 Consider alternatives to virtual functions</h2><p id="00c80eb5-9f89-444c-90fd-23d319381b1a" class="">Say your <code>B</code> has a public virtual member function <code>B::vf()</code>.</p><h3 id="9075ab14-4d18-46e3-80d3-faf8f3ab96d0" class="">ROT</h3><ul id="df99d2b4-a5cb-426d-87e2-2b492e7eab50" class="bulleted-list"><li>alternatives include NVI and Strategy</li></ul><ul id="105b0ae6-e90d-4dc0-b58e-d7f2d01c78ce" class="bulleted-list"><li>moving member functions outside brings the problem of accessing non-public members</li></ul><h3 id="94cdb265-e4b7-4f13-a5e7-4a36499b7ebf" class=""><em>template method pattern</em> via <em>non-virtual interface</em> idiom</h3><p id="2b6a0275-ae67-4803-88cf-bd842e7f38b2" class="">Make <code>vf()</code> private and create an <code>f()</code>, the <em>wrapper</em>, that calls <code>vf()</code>.</p><ul id="4b7b1cd0-1a16-45f1-8c06-24d716621073" class="bulleted-list"><li>Advantage: able to do before/after stuff in the wrapper, which will be inherited by all <code>D</code>s.</li></ul><ul id="65069d93-0a31-41cf-8ffe-271f1efac5a9" class="bulleted-list"><li>It&#x27;s OK to redefine private member functions because <em>when</em> and <em>how</em> are two things.</li></ul><ul id="08d80d86-597a-4e51-8399-5b7ac212019a" class="bulleted-list"><li>Sometimes <code>B::vf()</code> must be protected, like when <code>D::vf()</code> needs to call it.</li></ul><h3 id="995c6c81-6a13-487c-a148-8bf9f3d72849" class=""><em>strategy pattern </em>via function pointers</h3><p id="375b4ebc-fe4b-4eaf-bfea-be7274a8e06c" class="">Instead of providing an interface in the class, declare a data member to be a function pointer and pass it in during constr&#x27;n.</p><ul id="63b7350a-4d16-4a6e-9177-1971f13da751" class="bulleted-list"><li>Advantage: Different instances of <code>D</code> can have different funcs.</li></ul><ul id="57a00d18-ba6c-4b78-8454-d9b9d095109c" class="bulleted-list"><li>Advantage: The funcs can be changed at runtime.</li></ul><ul id="f38bf1e8-1dbc-4844-ac51-d6937cbf2eea" class="bulleted-list"><li>Disadvantage: Might weaken encapsulation if the func needs to access internal members.<ul id="ac696fef-887c-40c7-b2f6-f058bb26f774" class="bulleted-list"><li>declare the func as <code>friend</code>, make more params in the func, expose more public...</li></ul></li></ul><h3 id="f0bd1609-58a7-403c-b2c8-3b06651db636" class=""><em>strategy pattern </em>via <code>function</code></h3><p id="df36ebb6-0fab-4f25-a8f5-f32da6d2aa9d" class="">Like above but a <code>function</code> holds any callable entity and takes care of conversion.</p><h3 id="2a2d0fd7-5e0f-4475-a7b3-aed2bd55a564" class=""><em>classic strategy pattern</em></h3><p id="0b40cf07-15c5-4c68-86d1-46559db51e4e" class="">Separate the hierarchies. So you want to customize the behaviour of your function in your derived classes... You can turn that function into a class <code>F</code>, and make <code>F</code> a member of <code>B</code>. </p><ul id="6b9ec007-166c-4f3d-8f09-6488bf7adfc7" class="bulleted-list"><li><code>F</code> needs a virtual function to be overridden by its derivatives.</li></ul><ul id="e61eaace-d53e-4edd-ab1a-8cd3171550c8" class="bulleted-list"><li><code>B</code> can take derived classes of <code>F</code> and call that virtual func. This is a form of polymorphism.</li></ul><h2 id="66f605a2-ec3f-46f8-9444-4efc55142326" class="">36 Never redefine an inherited non-virtual function</h2><p id="0648752b-40ce-44b3-bc46-2ba83556f5a4" class="">Otherwise, how the object behaviour has nothing to do with the object itself but with the type of the pointer to it:</p><pre id="0a7b333d-f991-4116-b201-b91fde0e6912" class="code"><code>D x;
B* pB = &amp;x;
D* pD = &amp;x;
pB-&gt;f(); // calls B::f()
pD-&gt;f(); // calls D::f()</code></pre><p id="b563a4d3-24fa-4694-a3ab-6ac2f6cf9576" class="">It&#x27;s also semantically incorrect, because declaring a base member function non-virtual means &quot;this function interface should be preserved in all classes that can be treated <code>B</code>.&quot;</p><h2 id="bc5fb5db-4df0-4469-b03f-bc9e5ee411c8" class="">37 Never redefine a func&#x27;s inherited default param value.</h2><p id="04fd8e88-63ea-4ec8-88a3-a3ba8ac6ffba" class="">First of all, you shouldn&#x27;t redefine non-virtual functions in any way. Let&#x27;s limit to virtuals.</p><h3 id="0e37efad-cf69-44ea-a47f-1803dd8afe5d" class="">static &amp; dynamic types</h3><ul id="f9e7479d-6a17-4643-97b3-334e65268c32" class="bulleted-list"><li><em>static type</em>: the type you declare in the program text.</li></ul><ul id="5fe90cf2-4873-4281-9cfd-97b92064a175" class="bulleted-list"><li><em>dynamic type</em>: the type of the object to which the name currently refers.<ul id="cca90b68-f6d7-4f8c-af85-ae4f2e0000d1" class="bulleted-list"><li>not the pointed-to object; <code>D x; B* pB;</code>, <code>pB</code> has the dynamic type <code>D*</code>, not <code>D</code></li></ul></li></ul><h3 id="e4650383-af1e-440f-84a9-9e37562e1932" class="">the keng</h3><p id="909d521c-0cf2-41cd-8c53-b92abc127e55" class="">Default param values are <strong>statically bound</strong>, not dynamically bound; meaning, they are determined by the object&#x27;s static type. This is for runtime efficiency.</p><p id="fd081943-25dd-4ea7-9d01-c335ad53ba82" class="">You also can&#x27;t leave out the default param in func override of derived class because it won&#x27;t get inherited.</p><h3 id="9740dbf8-b9e7-44f7-9cbd-d923100fb699" class="">solutions</h3><p id="84fd6099-d7f5-42dc-bfa2-3779114d0327" class="">Use NVI and put the default param value only to the wrapper.</p><h2 id="463ded3f-a558-479e-89b7-5feb587a2eaf" class="">38 Model &quot;has-a&quot; &amp; &quot;impl&#x27;ed-in-terms-of&quot; via composition.</h2><h3 id="a748b2e9-948b-4a90-9b49-edfc1cd1c4bb" class="">terminology</h3><p id="9576df21-ffc5-4ff5-83f3-538cc03bc17b" class=""><em>Composition </em>arises when objects of one type contain objects of another type.</p><p id="d442cd23-e047-4f9c-9f6e-4f924f8c0fec" class="">There are two <em>domains </em>in your software:</p><ul id="306f9c08-6e88-4d07-8608-ac40d16a1af4" class="bulleted-list"><li><em>application domain </em>(corresponds to &quot;has-a&quot;)</li></ul><ul id="e097f97c-2dfd-43ff-8a90-029de01c5ce5" class="bulleted-list"><li><em>impl&#x27;n domain </em>(corresponds to &quot;impl&#x27;ed-in-terms-of&quot;)</li></ul><h3 id="9b5f3678-5d34-4940-a80a-518b53d2e8c2" class="">diff between &quot;is-a&quot; &amp; &quot;impl&#x27;ed-in-terms-of&quot;</h3><p id="ef00e408-30fd-47a5-a5a7-59288c1fc13a" class="">This determines whether you should use public inheritance.</p><p id="a19eeb69-13f6-4a60-a073-c1def8c2df8e" class="">E.g. you want to impl&#x27;t a <code>Set</code> using <code>std::list</code>. You shouldn&#x27;t publicly inherit <code>list</code> because they have different behaviours (when adding duplicate items). You should use composition.</p><p id="96c28965-5a21-473e-b24c-e9175dedeb12" class=""><code>Set</code> &quot;is-not-a&quot; <code>list</code>. <code>Set</code> is &quot;impl&#x27;ed-in-terms-of&quot; a <code>list</code>.</p><h2 id="e31c27c2-b54d-4058-ae58-6c66fd9a9015" class="">39 Use private inheritance judiciously</h2><h3 id="3b5f5b7f-e21e-4afb-b9a2-ccf2e9d11070" class="">ROT</h3><ul id="b8467f67-a517-4015-b4e6-9782232af960" class="bulleted-list"><li>private inheritance means &quot;impl&#x27;ed-in-terms-of&quot;</li></ul><ul id="95099cc8-974b-41c0-a027-d8a666d1e09c" class="bulleted-list"><li>used when a derived class needs<ul id="a8230f0c-8211-4633-9a5f-4821ec72e5b2" class="bulleted-list"><li>access to protected base class members</li></ul><ul id="d25bc302-9d42-4706-9851-31c1695f1b11" class="bulleted-list"><li>to redefine inherited virtual functions</li></ul></li></ul><ul id="d0681ccb-2f07-4786-b0ee-f5fd6455c095" class="bulleted-list"><li>empty base optimization</li></ul><h3 id="dcd0d169-2372-4cb4-aa8b-c5625850dfa6" class="">behaviour of private inheritance</h3><ul id="c48e98bf-a18d-4669-bff5-5f487bbe654a" class="bulleted-list"><li>Compilers will not implicitly convert derived class to base class</li></ul><ul id="f855794f-a144-4f93-8835-3f2ea0b64feb" class="bulleted-list"><li>In the derived class, inherited members are private, regardless of their visibility in base class</li></ul><h3 id="dc79e492-528d-4cb6-bb11-a8c885f87356" class="">meaning</h3><ul id="49dfb51a-0028-4567-bd69-0e0b73fa1eb2" class="bulleted-list"><li>Means &quot;impl&#x27;ed-in-terms-of.&quot;</li></ul><ul id="fa50203e-9461-4410-acdc-5762c3d252d2" class="bulleted-list"><li>You privately inherit <code>D</code> from <code>B</code> because you want to take advantage of some features available in <code>B</code>.</li></ul><ul id="da91a492-5b77-44a4-89ca-4afe66db370c" class="bulleted-list"><li>Private inheritance is purely a impl&#x27;n technique. It&#x27;s not about designing.</li></ul><ul id="31352c7f-8dc7-4e23-ae4f-9d5fb0a21fea" class="bulleted-list"><li>Referring to <a href="https://www.notion.so/nerrons/Effective-C-73e0037beb024637b5e5e08848f8d4fd#60e1513cc4e4441ab8a6a7b13a439127">Item 34</a>, private inheritance only inherits impl&#x27;n, not interface.</li></ul><h3 id="e26a79e9-959d-4c9e-9e81-9a6e6350897d" class="">when to use</h3><p id="2cad3f1e-9537-4997-ba50-590caaa5fa01" class="">While they express the same meaning, almost always use composition because it&#x27;s simpler. There are cases when you must use private inheritance:</p><ul id="16c7e18c-f83f-4414-ae75-014f55577936" class="bulleted-list"><li>You want to override a virtual function in the integrated class.</li></ul><ul id="a23ff9d2-ba76-4a25-ab14-7a9725b467ac" class="bulleted-list"><li>You want to access a protected member of the integrated class.</li></ul><h3 id="efa19b46-a82a-429d-b6a0-9187f38af56d" class="">example: integrating a utility class</h3><p id="42b368c9-6238-41e7-92d5-03a36dea1eb7" class="">You have a <code>Timer</code> class:</p><pre id="8cea1a63-42fc-4957-a37c-2a4b99e8c00a" class="code"><code>class Timer {
public:
	explicit Timer(int tickFreq);
	virtual void onTick() const;
};</code></pre><p id="d7003543-1d8f-413b-aa63-c12b8cbc292c" class="">You integrate that in your <code>Widget</code> using private inheritance:</p><pre id="227eb1f1-4d99-4ca6-950f-b271a894da9e" class="code"><code>class Widget: private Timer {
private:
	void onTick() const override; // Redefine the virtual function
};</code></pre><p id="5cb2685c-3bf3-40dc-bd4a-f6466e1a0e1b" class="">So you can reuse things in <code>Timer</code> without exposing <code>onTick</code>.</p><p id="a76fe284-c306-442d-9c3b-a19afa21e721" class="">But private inheritance is not the only way. You can use composition if you like, by wrapping a &quot;inheritor&quot; class that inherits <code>Timer</code> to use its virtual interface:</p><pre id="7525832f-bdc8-4799-adfd-dd57fae0655a" class="code"><code>class Widget {
private:
	class WidgetTimer : public Timer {
	public:
		virtual void onTick() const;
	};
	WidgetTimer timer;
	// ...
};</code></pre><p id="6672138d-b189-4cea-839b-50f2c942680d" class="">This has two advantages:</p><ul id="e174d2ab-7594-4171-8926-e6cb5d883715" class="bulleted-list"><li>You can prevent derived classes from <code>Widget</code> to redefine <code>onTick</code><ul id="6cff4b6d-87db-47ea-96f6-eaa2bf4ed295" class="bulleted-list"><li>If <code>Widget</code> privately inherits from <code>Timer</code>, <code>Widget</code>&#x27;s subcls can redefine <code>onTick</code></li></ul><ul id="f9fcc237-a83e-4e0c-9fe4-c97e2be0c642" class="bulleted-list"><li>Since <code>WidgetTimer</code> is private, <code>Widget</code>&#x27;s subcls don&#x27;t have access to it</li></ul></li></ul><ul id="30014646-0bd0-4fac-9725-9c3d5826222c" class="bulleted-list"><li>It eliminates a compilation dependency<ul id="5038201a-5cc3-4492-8438-28165556987b" class="bulleted-list"><li>If <code>Widget</code> privately inherits from <code>Timer</code>, <code>Timer</code>&#x27;s definition must be available when <code>Widget</code> is compiled, leading to an <code>#include &quot;Timer.h&quot;</code>.</li></ul><ul id="41e6d3ff-25af-4ecc-ab34-6fb0695afbf3" class="bulleted-list"><li>Move <code>WidgetTimer</code> outside and use a pointer to it in <code>Widget</code>➡️forward-declaration.</li></ul></li></ul><h3 id="2a61dd33-cc2b-4ef7-a068-397c3dd6533d" class="">edge case: <em>empty base optimization</em></h3><p id="69a60591-c312-408f-9c74-bd8aadaa4aed" class="">This only concerns privately inheriting from an empty class to reduce size...</p><h2 id="55f75a26-6144-43c5-9644-d1c2b5537acd" class="">40 Use multiple inheritance judiciously</h2><h3 id="0bf45091-f89c-4f6b-987d-46de3db1e725" class="">problems with MI</h3><ul id="2623d982-5a4e-4c4e-9701-0127e74f8704" class="bulleted-list"><li>Ambiguity: it&#x27;s possible to inherit the same name from more than one base class<ul id="2928a4c0-61f9-47af-a49a-df2f0d8249ae" class="bulleted-list"><li>Compiler refuses to compile when ambiguity is found</li></ul><ul id="8a3679f3-ae4a-4d99-a107-2709a0c2b83c" class="bulleted-list"><li>Qualify the call with base class namespace</li></ul></li></ul><ul id="4a9a3431-cd28-4a58-98d8-297bf4d481bb" class="bulleted-list"><li>Deadly MI Diamond:<ul id="4bc8e7f0-df2f-4827-96da-e2f278492373" class="bulleted-list"><li>Happens when <code>D</code> inherits from <code>B1</code> and <code>B2</code>, which both inherit from <code>A</code>.</li></ul><ul id="048989f3-3ffb-484d-823d-b452a273aa7e" class="bulleted-list"><li>C++ will replicate all data member fields inherited from <code>A</code>.</li></ul><ul id="ffff7674-9583-4187-b6fe-906461d6f847" class="bulleted-list"><li>To override the default behaviour:<ul id="dce8e342-09e4-407e-8adf-c18e310e1c72" class="bulleted-list"><li>Make the class with the duplicatable data a <em>virtual base class</em>. This way make references &quot;resolve&quot; to the correct instance and leave only one piece of data.</li></ul><ul id="affa870e-12f8-4620-a92c-c37cb6d5a1ce" class="bulleted-list"><li>It&#x27;s most practical when the base class has no data</li></ul></li></ul></li></ul><h3 id="c687d83a-5a58-410c-9329-14c55cdfaed2" class="">One possible use...</h3><p id="e4051346-f55a-453d-bdc9-9e4678e84ac1" class="">Multiple inheritance is very useful for inheriting a publicly inheriting an interface (possibly pure virtual) class and privately inheriting a class that facilitates impl&#x27;n.</p><h1 id="6467c496-3942-4ccf-8f12-8711ec5b2f5e" class="">Templates and Generic Programming</h1><h2 id="39e4ed04-8e7b-4e79-8b7e-e2cbb36ce462" class="">41 Know implicit interfaces &amp; compile time polymorphism</h2><h3 id="3a91acbe-0d56-498e-be78-502258d03adc" class="">explicit vs implicit; compile time vs runtime</h3><p id="258798be-872e-411b-99b9-265ed8387a94" class="">Without templates...</p><ul id="a7bd7c89-c3bb-4a39-8d81-85fdc552dec9" class="bulleted-list"><li>When you declare an object to be of a type <code>Widget</code>, that object must support an <em>explicit interface</em>, i.e. the interface defined by <code>Widget</code>.</li></ul><ul id="e2594adb-5c9b-4148-9710-e8c27f622310" class="bulleted-list"><li>Virtual functions exhibit <em>runtime polymorphism</em>: the specific function to call is determined at runtime based on that object&#x27;s dynamic type.</li></ul><p id="c0938d83-9b4a-40ee-a60c-12cdf320e7ea" class="">With templates...</p><ul id="ce0cb559-f7d2-4f3e-b46a-42caca5a152c" class="bulleted-list"><li>The interface the object must support can no longer be named easily (because no idea what exactly the type is), and will depend on the series of operations performed on that object.</li></ul><ul id="450a8ae9-ddfd-4064-976f-0b7dfd280fa2" class="bulleted-list"><li>Operations on that object may involve instantiating templates, which occurs during compilation. We have <em>compile time polymorphism</em> because <strong>i</strong>nstantiating function templates with<strong> different template params </strong>leads to<strong> different functions being called</strong>.</li></ul><h3 id="c7f6d1fd-7d75-45c9-b76d-cb6b0b3e7f3d" class="">more on explicit and implicit interfaces</h3><ul id="4d69b46e-0357-452f-a68d-0882d0eadd69" class="bulleted-list"><li>An explicit interface is usually a set of function signatures/declarations.</li></ul><ul id="0e7833a5-0cba-4a14-bdd4-37bf7ee5e7d2" class="bulleted-list"><li>An implicit interface is a sequence of valid <strong>expressions</strong>.<ul id="96afde7f-47f8-405c-808d-f70fa3e89a79" class="bulleted-list"><li>For operators, since they have overloading, an <code>a op b</code> expression is valid if there exists an operator <code>op</code> that takes types <code>X</code> and <code>Y</code>, where <code>a</code> has type <code>A</code> which can be implicitly converted to <code>X</code>, and <code>b</code> has type <code>B</code> which can be implicitly converted to <code>Y</code>.</li></ul></li></ul><ul id="d6129b74-9dea-49f8-8f4a-a1aaca97037c" class="bulleted-list"><li>Both are checked during compilation. Violation causes the code fail to compile.</li></ul><h2 id="fd504892-a293-4e36-9bce-21a3a2626a57" class="">42 Understand the two meanings of <code>typename</code></h2><ul id="827d8dd0-dbab-4cb1-ade1-63c40da487c4" class="bulleted-list"><li><code>template&lt;class T&gt;</code> == <code>template&lt;typename T&gt;</code></li></ul><h3 id="926c9b93-a5e5-40ec-83b4-de823705162c" class="">asserting nested dependent type names</h3><p id="a28337c9-f07e-490e-9b0f-bb66e552d835" class="">Things like <code>T::const_iterator</code> are</p><ul id="d084aa35-39cb-49fa-b4ce-9fecd8566fb7" class="bulleted-list"><li><em>dependent names</em>: Names in a template that are dependent on a template parameter.</li></ul><ul id="c4ab1910-b2c9-42bd-8260-66807467299d" class="bulleted-list"><li><em>nested names</em>: Names nested inside a class.</li></ul><p id="3dde5dc1-4a6c-4bfc-b850-2f82d1fc11e4" class="">C++ consider nested dependent type names ambiguous by default; so we need to prepend a <code>typename</code> to the name.</p><p id="b9c03970-ce82-4c04-a7c4-4e7fbff4e8c7" class="">E.g. <code>C::type</code>. We don&#x27;t know what <code>C</code> is so we don&#x27;t know if <code>type</code> is really a type.</p><p id="332cdc09-22b9-4b1a-8e74-a59644bed6b2" class="">Only exceptions where you should not prefix <code>typename</code> when using nested dependent names:</p><ul id="c93879cd-7193-49ba-a695-f141d41ec5f2" class="bulleted-list"><li>in the list of base classes when declaring a derived class</li></ul><ul id="854f4c37-205c-41d3-b0e3-1686bf812af7" class="bulleted-list"><li>in member initialization lists</li></ul><h2 id="d6a5d093-db7c-40ae-8738-04477f3298dd" class="">43 Know how to access names in templatized base classes</h2><p id="33b62d7f-0c6f-4bd0-b236-2b1b5ae4e878" class="">Say we have this, which won&#x27;t compile:</p><pre id="1a17e0aa-f35d-486b-a30a-19ce626e7b35" class="code"><code>template&lt;typename T&gt;
class D : public B&lt;T&gt; {
public:
	void fd() { fb(); } // fb() is supposed to be some function from B&lt;T&gt;
};</code></pre><h3 id="6af1c344-982e-4858-90d2-582e9b9c09d1" class="">reason</h3><p id="e9ead4d6-3b42-4495-ab16-bcb9bc0665dc" class="">Prior to template instantiation, the compiler doesn&#x27;t know what exactly the base class is, and consequently doesn&#x27;t know what names it has.</p><p id="43667d92-9eb5-4da7-a12f-16a04687dd50" class="">This is not a limitation of the compiler, and is reasonable behaviour. You can actually make the name missing in one of the <code>B&lt;T&gt;</code>s using partial/total specialization:</p><pre id="d2277177-34ad-49c7-b09a-78b21a209d0b" class="code"><code>template&lt;&gt;
class B&lt;int&gt; {}; // we don&#x27;t have fb() at all when T == int!</code></pre><h3 id="05719736-c64b-4785-8466-11098918d231" class="">solutions</h3><p id="bf4a7fd7-be06-4257-b785-9e25042165b1" class="">If you&#x27;re sure <code>fb()</code> exists in all instantiations of <code>B&lt;T&gt;</code>, you can force the compiler to search <code>B</code>. Note that if this assumption is found not true during instantiation, a compilation error is thrown.</p><ul id="bed37573-4096-417c-9164-4a6e94d1b8dc" class="toggle"><li><details open=""><summary>Prepend with <code>this-&gt;</code>.</summary><pre id="6bfdf04a-7514-4b51-a212-85a17f082c0f" class="code"><code>void fd() { this-&gt;fb(); }</code></pre></details></li></ul><ul id="26f52b46-a3dc-436d-b183-d773a5cf4d1f" class="toggle"><li><details open=""><summary>Employ a <code>using</code> declaration (See <a href="https://www.notion.so/nerrons/Effective-C-73e0037beb024637b5e5e08848f8d4fd#615a8ccb951843248fa2c29d9e333d6e">Item 33</a>).</summary><pre id="c91c43df-8380-453d-8fe6-232e8de3fe4e" class="code"><code>template&lt;typename T&gt;
class D : public B&lt;T&gt; {
public:
	using B&lt;T&gt;::fb;
	void fd() { fb(); }
}</code></pre></details></li></ul><ul id="e0fbced6-f9a5-4635-a24b-af6ffc9da8f5" class="toggle"><li><details open=""><summary>Explicitly qualify the function call of <code>fb()</code>. This is the least desirable: if <code>fb</code> is virtual, explicit qualifications turn off the virtual finding behavior.</summary><pre id="7f019210-2631-43ed-83dd-6f55cd058460" class="code"><code>void fd() { B&lt;T&gt;::fb(); }</code></pre><p id="c6bcab47-16e7-4462-a565-4868b3a99f03" class="">
</p></details></li></ul><h2 id="33478433-ba32-4151-8940-0fdf259dfd31" class="">44 Factor parameter-independent code out of templates.</h2><h3 id="0b102f00-ae98-4741-9fb3-4c0e8bdcc6ca" class="">ROT</h3><ul id="9f4ce34f-e9d5-40d0-9e0d-3783be941974" class="bulleted-list"><li>Make a new base class that has less template params.</li></ul><ul id="b2df4a19-e433-4063-8a6e-b56d285f2a33" class="bulleted-list"><li>Put functions that don&#x27;t absolutely need a template param there.</li></ul><ul id="edf5dbe1-098e-4c22-b96a-aab7fc227f74" class="bulleted-list"><li>Take care of communication: usually the derived needs to expose something to the base.</li></ul><h3 id="e9b22283-b081-4814-8adc-769469a8f6b8" class="">terminology</h3><ul id="18ac811e-b13c-4e2d-bb2e-39b5c9a5a251" class="bulleted-list"><li><em>code bloat</em>:<em> </em>binaries with (almost) replicated code.</li></ul><ul id="a251f517-4aa6-4d39-af43-048ba128a3ca" class="bulleted-list"><li><em>commonality and variability analysis</em>: look at the code (function/class/template), extract what&#x27;s common, and customize the common stuff with the varying parts.</li></ul><h3 id="706418a2-e0b0-47af-9c81-246868bf4138" class="">implicit replication about templates</h3><p id="96e7fefa-d3dc-4f50-8cdc-a9b9d7148e5e" class="">In non-template code, repetition is explicit in the source code. But for template code there&#x27;s only one copy of the source code and repetition occurs only after instantiation.</p><h3 id="82f857e3-8e57-45d7-88eb-d0d30f790290" class="">scenario</h3><p id="1acfe7e4-1cf0-4da3-a2d7-f4307b50c5a1" class="">Say we have a class representing a square matrix, with the dimension inside the type param:</p><pre id="3c0f5aa2-cb9a-4d64-9999-1272bb0ce68b" class="code"><code>template&lt;typename T, std::size_t n&gt;
class SquareMatrix {
public:
	void invert();
};</code></pre><p id="07a49a17-104b-4c55-9db8-14b1cb072cbe" class="">Then if we instantiate a lot of different square matrices, we will be instantiating as much <code>invert()</code> function too! While we maintain the interface of <code>SquareMatrix</code> which has two template params, we can internally put the <code>invert()</code> to somewhere else, namely a base class.</p><ul id="38e5e6e4-13bf-43ea-84fd-4f77e1ea7483" class="toggle"><li><details open=""><summary>Code:</summary><pre id="0147ac49-9c07-401b-bae1-6be5d21ee796" class="code"><code>template &lt;typename T&gt;
class SMBase {
protected: // invert is intended to be used by only SM
	void invert(std::size_t dim); // This shouldn&#x27;t be inlined
	// ...
};

template&lt;typename T, std::size_t n&gt;
class SM : private SMBase&lt;T&gt; {
private:
	using SMBase&lt;T&gt;::invert;
public:
	void invert() { invert(n); } // no additional cost cuz implicit inline
	// ...
};</code></pre></details></li></ul><p id="42803e8a-173f-4375-8626-673524154381" class="">However, this way <code>SMBase</code> has no idea where is the actual numerical data for the matrix. To avoid passing a pointer in all functions including <code>invert</code>, we give <code>SMBase</code> data members.</p><ul id="13a965c6-56f8-486d-9ae5-05d7aff90d15" class="toggle"><li><details open=""><summary>Code:</summary><pre id="da2b6224-7a6a-4639-bf79-6b35fd4c096c" class="code"><code>template&lt;typename T&gt;
class SMBase {
protected:
	SMBase(std::size_t n, T* pMem) : size(n), pData(pMem) {}
	void setDataPtr(T* ptr) { pData = ptr; }
	// ...
private:
	std::size_t size;
	T* pData;
};

typename&lt;typename T&gt;
class SM : private SMBase&lt;T&gt; {
public:
	SM() : SMBase&lt;T&gt;(n, data) {}
private:
	T data[n*n];
};</code></pre></details></li></ul><p id="ddcafecf-9e2c-42ae-99f8-c11fc1e96c78" class="">If the data is large, we can put it on the heap.</p><ul id="91156a9b-00c7-4acc-ac39-f3aa11b46988" class="toggle"><li><details open=""><summary>Code:</summary><pre id="74fe19d7-7bf0-4516-9576-80cf564fdfe1" class="code"><code>template&lt;typename T, std::size_t n&gt;
class SM : private SMBase&lt;T&gt; {
public:
	SM :
		SMBase&lt;T&gt;(n, nullptr),
		pData(new T[n*n])
	{ this-&gt;setDataPtr(pData.get()); }
private:
	std::unique_ptr&lt;T[]&gt; pData;
};</code></pre></details></li></ul><h3 id="6ad215fb-0ad4-4a3a-bf21-ffc6febab2b3" class="">conclusion</h3><p id="7e465f26-19ef-458e-9439-24199e245f38" class=""><strong>Final results:</strong> </p><ul id="19201c7c-4442-40b0-8ac7-b4dcad5e27d3" class="bulleted-list"><li>Many of <code>SM</code>&#x27;s member functions can be simple inline calls to (non-inline) base class versions that doesn&#x27;t get replicated when dealing with matrices of different dimensions.</li></ul><ul id="01b87f82-3164-4916-8cc2-36823a6548d8" class="bulleted-list"><li>Meanwhile, <code>SM&lt;int, 5&gt;</code> and <code>SM&lt;int, 10&gt;</code> are still different types.</li></ul><ul id="5ac5b8d8-5681-4279-a31a-1984e992303a" class="bulleted-list"><li>Decreasing executable size can improve locality of reference in instruction cache.</li></ul><p id="415eaec8-a59d-43ea-89a5-5abb5d08a1d3" class=""><strong>Potential costs:</strong></p><ul id="6a349870-c5c0-49e5-8fb6-8f252670a8af" class="bulleted-list"><li>Hardcoded versions can generate more optimized instructions.</li></ul><ul id="e7f8d344-38c1-4da7-9ade-af77898e55d9" class="bulleted-list"><li>You need complex mechanisms for the functions in the base class to use data from the objects in the derived class.<ul id="d5bf050e-387e-4972-8305-7438f052c18e" class="bulleted-list"><li>In our case, we use pointers. But there can be tons of decisions to make.</li></ul><ul id="0b2ce050-2f4a-424a-b696-482f990ede0a" class="bulleted-list"><li>Can increase object size.</li></ul><ul id="30d0c17f-8255-47f8-bb87-a77e15800e16" class="bulleted-list"><li>Can impose resource management difficulties.</li></ul></li></ul><p id="4d54d6f9-f9b7-4df4-82ae-46aa36d4e3f6" class="">Also, not only non-type template params lead to bloat. Like <code>vector&lt;long&gt;</code> and <code>vector&lt;int&gt;</code>, or different types of pointers, might be identical.</p><h2 id="f99461f7-cf52-41a4-b496-f9d633f18255" class="">45 Use memfunc templates to accept &quot;all compatible types&quot;</h2><h3 id="9940cb94-afb7-4df2-9c61-bcdcabe87f17" class="">ROT</h3><ul id="3d091971-be46-4bac-855b-18c2e728b6f0" class="bulleted-list"><li>use member function templates to accepts compatible types<ul id="1a476ade-dace-4e23-bb44-8ed8421e6b1e" class="bulleted-list"><li>use other internals to constrain</li></ul></li></ul><ul id="377e2781-5328-4263-adc1-32c3a89f7524" class="bulleted-list"><li>declare normal copy ctor and copy asgn oprt along side generalized ones</li></ul><h3 id="bdaf4fdf-7350-43eb-85c5-c6457093a3bf" class="">background</h3><p id="95b1ed8f-0477-4351-85f1-3a809324f6bd" class="">We may write <em>smart pointers</em>: objects that act like pointers but add functionalities. We want the smart pointers to support implicit conversions, like so:</p><pre id="4110d02d-5cc6-4830-8a11-5cc7c449c3d6" class="code"><code>SP&lt;Top&gt; pt1 = SP&lt;Middle&gt;(new Middle);
SP&lt;Top&gt; pt2 = SP&lt;Bottom&gt;(new Bottom);
SP&lt;const Top&gt; pct = pt1;</code></pre><p id="a0c1f49c-6cf6-41e8-83f5-4c62832e97b3" class="">By default they are considered totally different classes.</p><h3 id="944e8c90-982f-472e-9d14-0aca62dd37ba" class="">appetizer: <em>general copy ctors</em></h3><p id="058dc59f-7691-41f7-963e-5eec1018d0a9" class="">To support infinitely many conversions, we need ctor templates, or, <em>generalized copy ctors</em>.</p><pre id="558b7bef-b108-4b29-b942-8e63637ca6d1" class="code"><code>template&lt;typename T&gt;
class SP {
public:
	template&lt;typename U&gt; // not explicit so it supports implicit conversion
		SP(const SP&lt;U&gt;&amp; other);
};</code></pre><p id="469c66e5-05ef-447a-b88d-2522fa72c64e" class="">But that offers definitely too much possibilities (like you can construct an <code>SP&lt;Bottom&gt;</code> from an <code>SP&lt;Top&gt;</code>. To constrain the conversions, rely on the behavior of built-in pointers:</p><pre id="d7c77aae-2ab1-4146-96b5-d6c0d1a016b9" class="code"><code>public:
	template&lt;typename U&gt;
		SP(const SP&lt;U&gt;&amp; other) : heldPtr(other.get()) { /* ... */ }
	T* get() const { return heldPtr; }
private:
	T* heldPtr;</code></pre><p id="e423b553-7537-410b-b3ec-1d95c5ece7eb" class="">This only compiles if there&#x27;s an implicit conversion from <code>U*</code> to <code>T*</code>.</p><h3 id="47ebe655-d411-453d-ae9a-c66d34135dac" class="">supporting assignments and other conversions</h3><ul id="32314044-7f3b-4971-93b6-7b9c57d6e8eb" class="toggle"><li><details open=""><summary>A possible declaration of <code>shared_ptr</code>.</summary><pre id="f8a28fcc-71f8-4ba9-9c93-fbd5d7edec3b" class="code"><code>template&lt;typename T&gt;
class shared_ptr {
public:
	template&lt;typename Y&gt;
		explicit shared_ptr(Y* p);
	template&lt;typename Y&gt;
		shared_ptr(shared_ptr&lt;Y&gt; const&amp; sp);
	template&lt;typename Y&gt;
		explicit shared_ptr(weak_ptr&lt;Y&gt; const&amp; wp);
	template&lt;typename Y&gt;
		explicit shared_ptr(unique_ptr&lt;Y&gt; const&amp; up);
	template&lt;typename Y&gt;
		shared_ptr&amp; operator=(shared_ptr&lt;Y&gt; const&amp; sp);
	template&lt;typename Y&gt;
		shared_ptr&amp; operator=(unique_ptr&lt;Y&gt; const&amp; up);
};</code></pre></details></li></ul><p id="6ef381e9-e10d-42e0-a01b-04501e100239" class="">From the example above,</p><ul id="b3995fa5-6441-4b6c-a8b1-9995a522e362" class="bulleted-list"><li>All ctors except the generalized copy constructor are <code>explicit</code>.<ul id="b62cdbc4-a831-468b-9e48-cf4b1cf5f4db" class="bulleted-list"><li>implicit conv&#x27;n from <code>shared_ptr&lt;X&gt;</code> to <code>shared_ptr&lt;Y&gt;</code> is allowed</li></ul><ul id="459a68e2-bc2c-4b67-9589-5ad528e98358" class="bulleted-list"><li>implicit conv&#x27;n from a raw pointer or another kind of smart pointer is not allowed</li></ul><ul id="3c4bda2f-fe7a-4c77-be3d-7376ef7fa0d7" class="bulleted-list"><li>explicit conv&#x27;n of above is fine</li></ul></li></ul><h3 id="df9a66ec-ff8a-48c6-88bb-426c11258725" class="">about the default ctors/operators</h3><p id="afc857a6-05af-46de-bb52-eace1b1a6e79" class="">Declaring a generalized copy ctor doesn&#x27;t stop the compiler from generating a &quot;normal&quot; ctor.</p><ul id="e7b0e092-0892-4fb1-a503-d8a76a9c1e06" class="toggle"><li><details open=""><summary>To take full control, declare both of them:</summary><pre id="73696ced-d963-412d-ada7-178830e26bb2" class="code"><code>template&lt;typename T&gt;
class shared_ptr {
public:
	shared_ptr(shared_ptr const&amp; sp);
	template&lt;typename Y&gt;
		shared_ptr(shared_ptr&lt;Y&gt; const&amp; sp);
	shared_ptr&amp; operator=(shared_ptr const&amp; sp);
	template&lt;typename Y&gt;
		shared_ptr&amp; operator=(shared_ptr&lt;Y&gt; const&amp; sp);
};</code></pre></details></li></ul><h2 id="9297ec22-6c5b-40bb-94c5-be3577595942" class="">46 Define non-member functions inside templates when type conversions are desired</h2><h3 id="6409672a-c20c-4212-b7ab-10b302eb9167" class="">ROT</h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="ad422ba3-84e8-4ddc-9ee1-ada5c85326d0"><div style="font-size:1.5em"><span class="icon">☢️</span></div><div style="width:100%">Implicit conversions are never considered during template argument deduction.</div></figure><p id="588a6cc4-49cf-423e-a99f-dcb1876cb90a" class="">When writing a class template that offers functions related to the template that should support <strong>implicit conversions</strong> on <strong>all parameters</strong>, define those funcs as friends inside the class template.</p><h3 id="aedbb513-027e-40cc-a8a2-056996af9ff8" class="">problem: function templates doesn&#x27;t have implicit conversions</h3><p id="9ff4304c-d569-409c-8ba8-d3345720aaff" class="">Suppose we have a <code>Rational</code> class with a <code>*</code> operator. (See <a href="https://www.notion.so/nerrons/Effective-C-73e0037beb024637b5e5e08848f8d4fd#f6865af88753461c93532e6dc93ce666">Item 24</a> for oprt declaration)</p><pre id="0ff3c247-f48e-4080-a33c-1a54588671da" class="code"><code>template&lt;typename T&gt; class Rational {
public:
	Rational(const T&amp; numerator = 0, const T&amp; denominator = 1);
	const T numerator() const;
	const T denominator() const;
};

template&lt;typename T&gt;
const Rational&lt;T&gt; operator*(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs)
{ /* ... */ }</code></pre><p id="4dda0cfb-211d-4881-9561-805b0bd46278" class="">Even though the oprt allows implicit conversions in both of their operands, this won&#x27;t compile:</p><pre id="18a0575d-aa7f-44d2-b11d-6c95034dfb90" class="code"><code>Rational&lt;int&gt; oneHalf(1, 2); // OK
Rational&lt;int&gt; one = oneHalf * 2; // ERROR! Won&#x27;t compile</code></pre><p id="080c8a0f-69a6-4f7b-a389-2e2e648069a6" class="">Because the compiler doesn&#x27;t know the type of the second operand.</p><ul id="05e30cd6-ace5-46fe-9167-e1f000bbf5ea" class="bulleted-list"><li>Deduction about <code>oneHalf</code>: <code>*</code>&#x27;s first param is previously declared <code>Rational&lt;int&gt;</code>, so the <code>T</code> must be <code>int</code>.</li></ul><ul id="9faf2888-2bb5-4b90-948d-250ea0e40a27" class="bulleted-list"><li>Deduction about <code>2</code>: <code>Rational</code> has a non-explicit ctor that will accept a <code>2</code>, but it won&#x27;t happen during template argument deduction (like in the callout above).<ul id="fc36beca-407e-45d9-951b-4260dd0d13c0" class="bulleted-list"><li>Such implicit conv&#x27;ns happen during function calls, but not during &quot;deciding what functions are valid&quot; phase, which happens when instantiating a func template.</li></ul></li></ul><h3 id="80fc0a4d-1505-4d46-88f0-451f12ddfdd3" class="">solution: <code>friend</code> inside class template</h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="57191616-cf47-4ff1-a0b5-38ee42cdaa08"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">A friend declaration in a template class can refer to a specific function.</div></figure><p id="eea6e1dc-0184-4a52-96d9-c3a62d8e5d90" class="">We abuse that fact to declare a concrete function (not a func template) when instantiating a class, so we type deduction happens at function-call level instead of template-instantiation level, which utilizes implicit type conversion.</p><pre id="af195f46-f0f0-4daf-b7a6-cbf99b849209" class="code"><code>template&lt;typename T&gt; class Rational {
public:
	friend const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs);
	/* Since in class template X, X means X&lt;T&gt;, that is a shorthand for this:
	friend const Rational&lt;T&gt; operator*(const Rational&lt;T&gt;&amp; lhs,
																		 const Rational&lt;T&gt;&amp; rhs); */
};</code></pre><p id="5678ae36-242b-495b-b1a4-227f830c2812" class="">Then as soon as we declare a <code>Rational&lt;int&gt;</code>, the class <code>Rational&lt;int&gt;</code> is instantiated, which automatically declares the friend function <code>operator*</code> which takes <code>Rational&lt;int&gt;</code> params.</p><p id="ca8a7092-a297-445a-9070-9339219e0e99" class="">That solved, we also need to define the operator somewhere. Maybe just in-place:</p><pre id="80e84e67-466d-4dc9-bf1a-5a1f99c803db" class="code"><code>template&lt;typename T&gt; class Rational {
public:
	friend const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs); {
		return Rational(lhs.numerator() * rhs.numerator(), /* ... */);
	}
};</code></pre><p id="7b1d9a28-9d90-4eab-aa56-15631752fbc0" class="">Notice that the friend function doesn&#x27;t access anything that&#x27;s not public. Why <code>friend</code>?</p><ul id="f8087291-1a64-40f8-aece-6a651268b5da" class="bulleted-list"><li>To make implicit conversions available on all parameters, we need to declare the operator <strong>a non-member function</strong>. (See <a href="https://www.notion.so/nerrons/Effective-C-73e0037beb024637b5e5e08848f8d4fd#f6865af88753461c93532e6dc93ce666">Item 24</a>).</li></ul><ul id="e95894a7-7fa5-404a-bb40-a0a57de91e60" class="bulleted-list"><li>To make implicit conversions available for function templates, we need to declare the function <strong>inside the class</strong>, so a concrete function gets instantiated with the class.</li></ul><p id="6ab16fb9-3cb4-4c1b-9783-25ab45c51d9a" class="">The only way to do that is with <code>friend</code>.</p><h3 id="233aa0e1-dbce-4a80-bc7c-9cc46d89d162" class="">improvement: minimize inlining</h3><p id="5e59592f-dfb8-4ad2-bc80-703d9d937c79" class="">The solution above will lead to inlining the operator function. </p><ul id="43f4d1fc-1cd4-42d0-a1d5-ce659a4a16cb" class="toggle"><li><details open=""><summary>To override that behavior, use the &quot;friend calls helper&quot; approach:</summary><pre id="6c758c2b-daf2-4ea0-b193-2f0f16e509ea" class="code"><code>template&lt;typename T&gt; class Rational;

template&lt;typename T&gt;
const Rational&lt;T&gt; doMult(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs);

template&lt;typename T&gt; class Rational {
public:
	friend const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs)
	{ return doMult(lhs, rhs); }
};

template&lt;typename T&gt;
const Rational&lt;T&gt; doMult(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs) {
	return Rational(lhs.numerator() * rhs.numerator(), /* ... */);
}</code></pre></details></li></ul><p id="dca80ea0-b1b0-4e68-9846-8e2f7e694a57" class="">The <code>doMult</code> will not support mixed-mode multiplication, but it doesn&#x27;t need to, because the operator will invoke the correct <code>doMult</code> specialization.</p><h2 id="168357ed-4758-4afb-8663-1d04c8d0eaad" class="">47 Use traits classes for information about types</h2><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="fe63f8d6-3910-4610-8648-a96f6b6769d8"><div style="font-size:1.5em"><span class="icon">⚠️</span></div><div style="width:100%">This section will need an update for C++11 <code>using</code>.</div></figure><h3 id="18932b8a-469f-42f2-9f74-9b6b40473ef7" class="">mini review: 5 types of iterators</h3><ul id="5d48ac84-f8ca-4f60-9107-e9aca1d13bbe" class="bulleted-list"><li><em>input iterator</em>: move only forward, 1 step at a time, only read what they point to, only once.<ul id="192bbb38-31b7-41d9-9b7e-1ad5eedbf367" class="bulleted-list"><li>modeling the read pointer into an input file (<code>istream_iterator</code>)</li></ul></li></ul><ul id="1eccdfc9-9c84-4283-8d26-4bb290f5208d" class="bulleted-list"><li><em>output iterator</em>: move only forward, 1 step at a time, only write to what they point to, once.<ul id="014da58f-a869-474f-b8aa-1384df3b90de" class="bulleted-list"><li>modeling the write pointer into an output file (<code>ostream_iterator</code>)</li></ul></li></ul><ul id="c576a41d-3e7a-4bd9-96c5-76d2aab52005" class="bulleted-list"><li><em>forward iterator</em>: plus read/write more than once (<code>slist</code>)</li></ul><ul id="41aa6b65-5792-4a73-a7c5-390bb5e9f166" class="bulleted-list"><li><em>bidirectional iterator</em>: like forward iterators but can move back and forth<ul id="7924c300-156e-45ce-8fde-4a63372473c6" class="bulleted-list"><li>(<code>std::list</code>, <code>set</code>, <code>map</code>, <code>multiset</code>, <code>multimap</code>)</li></ul></li></ul><ul id="21da3644-a911-4ea7-8200-b6d668ab985d" class="bulleted-list"><li><em>random access iterator</em>: perform iterator arithmetic (jump arbitrary distance in constant time)<ul id="ccd17aaa-281d-4973-be45-cb98c234fcf3" class="bulleted-list"><li>modeling on built-in pointers (<code>vector</code>, <code>deque</code>, <code>string</code>)</li></ul></li></ul><h3 id="d7912891-a103-45cf-9135-bbfa7b951493" class="">iterator tag</h3><ul id="567017bc-4a83-40c9-8f99-e1585d4a9f00" class="toggle"><li><details open=""><summary>For every kind of iterator there&#x27;s a &quot;tag struct.&quot;</summary><pre id="858bcba1-cd82-4c64-8ab6-3d851ba0542b" class="code"><code>struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag: public input_iterator_tag {};
struct bidirectional_iterator_tag: public forward_iterator_tag {};
struct random_access_iterator_tag: public bidirectional_iterator_tag {};</code></pre></details></li></ul><h3 id="7a2e6552-634f-4ea4-a247-d0827f73f895" class="">introducing traits</h3><p id="01c39fa8-73e3-471b-8f24-f0186549526d" class=""><em>Traits</em> allow clients to get information about a <strong>type</strong> during <strong>compilation</strong>. They aren&#x27;t a language feature; just a convention.</p><p id="ceb8033a-b48d-4c4c-b054-31255f726e91" class="">One requirement of using traits is that, traits should be applicable to built-in types as well; in other words, traits need to be a universal tool for all types. (e.g. when a built-in type doesn&#x27;t have a trait, the program should be aware of that, instead of just break.)</p><p id="a6f23900-c309-41cb-a989-653364c9ea57" class="">Thus, traits are something <strong>outside</strong> of classes (because otherwise the built-in types won&#x27;t have them). The standard way of implementing traits is to make a template of the trait <code>struct</code>(ironically called <em>traits classes</em>) and let different specializations have different content.</p><p id="988cc7d1-dc84-4a04-883a-2699a415559d" class="">Traits are implemented differently for built-in types and user-defined classes.</p><h3 id="ee83aed2-b6d2-4edc-a440-9443b2c69da4" class="">traits and user-defined classes</h3><p id="77dc3be0-0eb3-442a-a075-4bc213fe1950" class="">Simple! Let the class declare a trait for themselves and our trait class just gathers the info.</p><p id="8c46c249-c237-4678-8052-1255eb80ff35" class="">Provide a public <code>typedef</code> from the iterator tag to <code>iterator_category</code> (just a convension).</p><pre id="88291331-b01a-4f03-9588-b6a05f2498e8" class="code"><code>template&lt;typename T&gt; class deque {
public:
	class iterator {
	public:
		typedef random_access_iterator_tag iterator_category;
	};
};</code></pre><p id="e65c86c6-fba9-4fff-a56d-5897876d9c95" class="">In the trait class, respect whatever the iterator says.</p><pre id="54ceb3c2-2182-40c9-bcdf-30f1aae6e855" class="code"><code>template&lt;typename IterT&gt; struct iterator_traits {
	typedef typename IterT::iterator_category iterator_category;
};</code></pre><h3 id="0840fc6b-72b1-4cd4-b20d-a48d27af8140" class="">traits for built-in types</h3><p id="713806ee-d958-4749-b82c-7ff6181aa05f" class="">For iterators, we also need to consider raw pointers. Since we can&#x27;t attatch trait information inside a &quot;pointer class,&quot; we place the info under our trait class, using partial specialization.</p><pre id="1fdabac0-bf17-4584-87db-bbd701c1df93" class="code"><code>template&lt;typename T&gt; struct iterator_traits&lt;T*&gt; { // partial
	typedef random_access_access_iterator_tag iterator_category;
};</code></pre><h3 id="aafad101-3c63-485c-8d6f-122e45a70e27" class="">procedure of designing and implementing traits</h3><ul id="3ad6a23e-295c-4db7-b821-94193cbdc4ce" class="bulleted-list"><li>Identify the info you need about types.</li></ul><ul id="62d2df58-14d6-4b7c-b67b-1460bbf1b4de" class="bulleted-list"><li>Choose a name for that info.</li></ul><ul id="124ba971-941f-4fe1-9ff8-0e16eb0a93cd" class="bulleted-list"><li>Provide a template and a set of specializations.</li></ul><h3 id="d8543011-f65a-43a8-9d31-d1c1e6409d11" class="">using traits</h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="61893c47-f236-4d17-9e65-07a613a448c5"><div style="font-size:1.5em"><span class="icon">⚠️</span></div><div style="width:100%">Now consider <code>if constexpr</code>.</div></figure><ul id="fcedc950-6ccf-4334-83b0-e69f671722ff" class="toggle"><li><details open=""><summary>You shouldn&#x27;t just compare type traits in <code>if</code> statements cuz: it&#x27;s runtime; it bloats exe size; it leads to compile problems cuz there can be mismatched types that still need to be compiled.</summary><pre id="186609c9-ad20-4878-84aa-bf91e1320ff2" class="code"><code>template&lt;typename IterT, typename DistT&gt;
void advance(IterT&amp; iter, DistT d) {
	if (typeid(typename std::iterator_traits&lt;IterT&gt;::iterator_category) ==
			typeid(std::random_access_iterator_tag)) {
		iter += d; // Even when sometimes IterT doesn&#x27;t support operator+=,
							 // the compiler still requires this typecheck to pass.
							 // That prevents compiling.
	} else {
		/* Do things without using operator+= ... */
	}
}

std::list&lt;int&gt;::iterator iter; // Doesn&#x27;t support operator+=
advance(iter, 10); // ERROR!</code></pre></details></li></ul><p id="2be4c840-63c2-477f-87b9-c4c798d1919f" class="">You want a conditional construct that gets evaluated during compilation. That&#x27;s overloading!</p><p id="ecf3cbd1-b5a0-4a69-b2e5-582fa30136d2" class="">Create multiple aux functions for the function where you want to utilize traits, and use an additional parameter (called the <em>traits parameter</em>) to distinguish different traits.</p><h2 id="0bad65d3-5896-4b45-86c6-beed688f888d" class="">48 Be aware of template metaprogramming</h2><h3 id="7c7a1605-fb25-4ed9-9b7e-b3c4f38da571" class="">Hello World: factorial</h3><pre id="93cddeb4-2070-4f5a-9769-e49b1240accf" class="code"><code>template&lt;unsigned n&gt;
struct Factorial {
	// enum hack; every instantiation has a unique value
	enum { value = n * Factorial&lt;n-1&gt;::value };
};

template&lt;&gt;
struct Factorial&lt;0&gt; {
	enum { value = 1 };
};</code></pre><h3 id="4d8566c7-19b5-4891-aa4f-3a63294afc3a" class="">why even bother</h3><ul id="336d971d-3cf0-4b73-988e-fe45cb1baddf" class="bulleted-list"><li>Ensure dimensional unit correctness.</li></ul><ul id="8e75ef57-1d55-4da9-aa39-82698642ec24" class="bulleted-list"><li>Optimize matrix operations.<ul id="2d2666f0-733e-4d67-9c35-08801ac11841" class="bulleted-list"><li>e.g. when multiplying huge matices.</li></ul><ul id="fbe0fa63-5029-451a-a7a9-c20e82d3de40" class="bulleted-list"><li>use <em>expression templates</em> to avoid temporary object creation and merge loops</li></ul></li></ul><ul id="ed554508-65a4-40e3-a35c-7aa51d2178c0" class="bulleted-list"><li>Generating custom design pattern implementations.<ul id="110d2dd9-fa1a-47cf-9cb7-1254cbb1537c" class="bulleted-list"><li>use <em>policy-based design</em> to create independent design choices.</li></ul></li></ul><h1 id="bc079859-94f8-4e3d-a088-90a3c115b298" class="">Customizing <code>new</code> and <code>delete</code></h1><h2 id="4210a4c1-a85e-48e2-89b2-a5cc95d5550d" class="">49 Understand the behavior of the new-handler</h2><h3 id="a8e0223c-12f1-46b3-ac5e-b7c7d5f946e2" class="">ROT</h3><ul id="ed83a8ec-dfdc-4e23-bb70-7fb63553c09a" class="bulleted-list"><li>use new-handlers to allocate more memory in case allocation fails</li></ul><ul id="8d821c0f-5477-4e90-b2e1-6c0d417057d3" class="bulleted-list"><li>be aware of the reusable way to make class-specific new-handlers using <code>set_new_handler</code></li></ul><h3 id="aa80ee24-3562-47ea-a62a-cd4e491d3a0b" class="">introducing new-handlers</h3><p id="f6d8dd1a-aa19-4bf1-8c1a-83ec364024f7" class="">Before <code>operator new</code> throws an exception due to memory allocation error, it calls the <em>new-handler</em> to handle it. To customize the behavior, use <code>std::set_new_handler</code> from <code>&lt;new&gt;</code>.</p><pre id="bd2e1fbc-5406-485d-91c4-7258c103416d" class="code"><code>namespace std {
	// new_handler = ptr to a func that takes and returns nothing
	typedef void (*new_handler)();

	// takes and returns a new_handler
	// throw() means the func shouldn&#x27;t throw any exceptions
	// returns the old new_handler
	new_handler set_new_handler(new_handler p) throw();
}</code></pre><h3 id="bd57cd3c-6ae2-433b-a376-cf050160c10b" class="">writing new-handlers</h3><p id="4ef1b122-4f14-4673-aa7f-20572c152f46" class=""><code>operator new</code> calls the new-handler <strong>repeatedly</strong> if it can&#x27;t allocate the memory. Therefore, a new-handler must do one of the following in one round:</p><ul id="4990988e-2aeb-4157-8f10-ff3f4f7d88f7" class="bulleted-list"><li>Make more memory available for the next round.<ul id="6c552fc8-2c99-4232-8261-092b09620853" class="bulleted-list"><li>Popular impl&#x27;n: reserve large memory at start-up; release some for new-handlers.</li></ul></li></ul><ul id="eb9f27a1-7e79-4e7a-a0eb-4a79c2a5257a" class="bulleted-list"><li>Install a different new-handler if needed.<ul id="4668d30e-f021-4900-a647-3330432e7eba" class="bulleted-list"><li>If current new-handler can&#x27;t make any more memory available, call <code>set_new_handler</code> with another one, or modify its own behavior.</li></ul></li></ul><ul id="10dc9b35-9736-4292-8e42-3b9438b29d7c" class="bulleted-list"><li>Deinstall the new-handler to force throwing.<ul id="0c5f819b-bd40-49fc-a94f-c556a4006726" class="bulleted-list"><li>Pass a <code>nullptr</code> to <code>set_new_handler</code>. Next round throws.</li></ul></li></ul><ul id="1d83a7cd-044d-45e2-8e7b-7137286cec00" class="bulleted-list"><li>Throw an exception.<ul id="5d228919-4c6a-4b3d-b587-fd334e6879cf" class="bulleted-list"><li>Usually <code>bad_alloc</code> or derived. Propagates to site originating the request for memory.</li></ul></li></ul><ul id="d2f4204f-fc7e-44b6-963c-7cb8cb36a340" class="bulleted-list"><li>Not return.<ul id="2eb410b0-24ce-434d-84a6-e5f4029f18f3" class="bulleted-list"><li>Usually by calling <code>abort</code> or <code>exit</code>.</li></ul></li></ul><h3 id="63ce1392-7e31-4e3f-92cb-5964ed2edbc4" class="">proposal for class specific new-handlers</h3><ol id="7510e6da-b85a-4451-9262-b1dc7ffae973" class="numbered-list" start="1"><li>Put a static new-handler data member (<code>currentHandler</code>) in the class.</li></ol><ol id="3000a806-6c15-4baf-8dad-6196dc7b23ca" class="numbered-list" start="2"><li>In the impl&#x27;n file, define the <code>currentHandler</code> to be <code>nullptr</code>.</li></ol><p id="b54287dc-0d31-49cf-b930-b5dbe99b5a95" class="">Then, <code>Widget::set_new_handler</code> should play the same role as the global <code>set_new_handler</code>.</p><p id="e9785fa0-a537-4b63-bbe8-514de3877e97" class=""><code>Widget</code>&#x27;s <code>operator new</code> will do the following:</p><ol id="d0d3bcae-f6a8-4bb8-bb3b-0530551345ef" class="numbered-list" start="1"><li>Call the global <code>set_new_handler</code> with <code>Widget</code>&#x27;s own new-handler.</li></ol><ol id="438b13f5-6c2c-40ec-8880-e2c362b66430" class="numbered-list" start="2"><li>Call the global <code>operator new</code> to perform actual memory allocation.<ol id="a64a2790-0d30-426b-966b-56897cd2a5b0" class="numbered-list" start="1"><li>If allocation fails, the global <code>operator new</code> invokes <code>Widget</code>&#x27;s new-handler.</li></ol><ol id="0fc4c3e0-640c-42f9-992b-f359c591c5cc" class="numbered-list" start="2"><li>If ultimately cannot alloc memory, throw <code>bad_alloc</code>.</li></ol><ol id="873b6973-1d94-4beb-abc8-d27271c9874d" class="numbered-list" start="3"><li><code>Widegt</code>&#x27;s <code>operator new</code> restores old global new-handler; propagate exception.<ul id="67bf19a5-4ad6-4011-996e-6c2d256e974d" class="bulleted-list"><li>To ensure the old one is always restored, use resource-managing objs.</li></ul></li></ol></li></ol><ol id="3c8e8d3d-27ef-4297-908d-56142d8131d4" class="numbered-list" start="3"><li>When the global <code>operator new</code> succeeds in allocation, <code>Widget</code>&#x27;s <code>operator new</code> returns a pointer to the allocated memory.<ul id="4f78fc64-f9a6-40c0-813d-ddb87dca586d" class="bulleted-list"><li>dtor of the obj managing global new-handler automatically restores the old one.</li></ul></li></ol><h3 id="ccfc31fa-633e-4ef7-beb9-24c2641585aa" class="">implementing class specific new-handlers</h3><ul id="c5dece2e-7c34-4789-846a-a88019b28592" class="toggle"><li><details open=""><summary>Make <code>Widget</code> class.</summary><pre id="b6ec07d6-21ea-4d0e-9e9f-9bfe468dc650" class="code"><code>class Widget {
public:
	static std::new_handler set_new_handler(std::new_handler p) throw();
	static void* operator new(std::size_t size) throw(std::bad_alloc);
private:
	static std::new_handler currentHandler;
};</code></pre></details></li></ul><ul id="0ef4f9b3-c8d2-4f5c-8eed-5d31ea89c913" class="toggle"><li><details open=""><summary>Make <code>Widget</code>&#x27;s <code>set_new_handler</code>.</summary><p id="c0cf21a5-1834-4e18-99b2-3eaea8fbc160" class="">It really isn&#x27;t a <code>set_new_handler</code> cuz it doesn&#x27;t change the new-handler at all; it just records the <code>Widget</code>-specific new-handler to be installed when <code>new</code>ing a <code>Widget</code>.</p><p id="cf044e70-c146-4e30-9337-dd8d5e1abaaa" class="">Like the original <code>set_new_handler</code> it returns the old one so it can be restored later.</p><pre id="a60a947a-6c3f-4091-9f49-775735321e81" class="code"><code>std::new_handler Widget::set_new_handler(std::new_handler p) throw() {
	std::new_handler oldHandler = currentHandler;
	currentHandler = p;
	return oldHandler;
}</code></pre></details></li></ul><ul id="b5048d6f-59e3-4987-b357-38b3b4ab9bce" class="toggle"><li><details open=""><summary>Make a resource managing class for global new-handlers.</summary><p id="3fcc50ab-2114-461d-809c-ba64fc3c58e3" class="">This holder holds one new-handler. Whenever this holder is destroyed, install the new-handler it holds.</p><pre id="e0e8cbee-47d9-4092-84ee-7de14f0eaf71" class="code"><code>class NewHandlerHolder {
public:
	explicit NewHandlerHolder(std::new_handler nh)
	: handler(nh) {} // keep track of the new new-handler

	~NewHandlerHolder()
	{ std::set_new_handler(handler); }

private:
	std::new_handler handler;

	NewHandlerHolder(const NewHandlerHolder&amp;) = delete;
	NewHandlerHolder&amp; operator=(const NewHandlerHolder) = delete;
};</code></pre></details></li></ul><ul id="8fcd027a-e798-44e1-b361-d9120b8f2772" class="toggle"><li><details open=""><summary>Override the <code>Widget</code>&#x27;s <code>operator new</code>.</summary><p id="83a26f67-dec2-45a2-b0a6-f075c3e8db94" class="">Use <code>NewHandlerHolder</code> to ensure new-handler restoration.</p><pre id="e745833a-e2d7-4cc3-9b21-d4f387b07661" class="code"><code>void* Widget::operator new(std::size_t size) throw(std::bad_alloc) {
	NewHandlerHolder h(std::set_new_handler(currentHandler));
	return ::operator new(size);
}</code></pre></details></li></ul><ul id="7a3f84ca-f57a-4475-8a94-f1f68b14ec32" class="toggle"><li><details open=""><summary>Client uses <code>Widget</code>&#x27;s new-handling just like the vanilla one.</summary><pre id="172e6c46-a22e-4a53-8a01-bb1470e1d21e" class="code"><code>void handmaster();

Widget::set_new_handler(handmaster);
Widget* pw1 = new Widget; // will call handmaster if alloc fails
std::string* ps = new std::string; // will call old global nh if fails

Widget::set_new_handler(nullptr);
Widget* pw2 = new Widget; // throws immed. if alloc fails</code></pre></details></li></ul><h3 id="4d16c54f-323d-4764-81ea-51b483e2f841" class="">reusing the class-specific new-handler feature</h3><p id="6edab43b-142f-4fe7-8429-49b1ea7b5e4f" class="">We extract <code>Widget</code>&#x27;s <code>set_new_handler</code> and <code>operator new</code> to a &quot;mixin-style&quot; base class.</p><p id="7435f11f-cacd-4aad-9df5-b436ebdd27e0" class="">Then we turn it into a template, otherwise since those goodies are static, all classes that inherited from it will have the same copy.</p><ul id="5b7ab854-6b07-4e4d-9916-0138a5b7df2f" class="toggle"><li><details open=""><summary>This is our <code>NewHandlerSupport</code> class.</summary><pre id="0887fcfb-0b3d-47bb-a335-b6d1d9407295" class="code"><code>template&lt;typename T&gt;
class NewHandlerSupport {
public:
	static std::new_handler set_new_handler(std::new_handler p) throw();
	static void* operator new(std::size_t size) throw(std::bad_alloc);
private:
	static std::new_handler currentHandler;
};

template&lt;typename T&gt;
std::new_handler
NewHandlerSupport&lt;T&gt;::set_new_handler(std::new_handler p) throw()
{
	std::new_handler oldHandler = currentHandler;
	currentHandler = p;
	return oldHandler;
}

template&lt;typename T&gt;
void*
NewHandlerSupport&lt;T&gt;::operator new(std::size_t size) throw(std::bad_alloc)
{
	NewHandlerHolder h(std::set_new_handler(currentHandler);
	return ::operator new(size);
}

// init each currentHandler to nullptr
template&lt;typename T&gt;
std::new_handler NewHandlerSupport&lt;T&gt;::currentHandler = nullptr;</code></pre></details></li></ul><ul id="0b77c642-4384-48ad-b368-1b722c114493" class="toggle"><li><details open=""><summary>This is how we use it.</summary><pre id="30843d72-8c06-4918-bb96-145181117dc2" class="code"><code>class Widget : public NewHandlerSupport&lt;Widget&gt; {
	/* as before, but without set_new_handler and operator new */
};</code></pre><p id="215a1c90-e073-4cb8-8749-11e7634c57c7" class="">
</p></details></li></ul><p id="31c4f506-c3ee-4cff-b5cd-dc7a36f12f05" class="">Note that <code>T</code> inherits from <code>Something&lt;T&gt;</code>. It&#x27;s called <em>curiously recurring template pattern </em>(CRTP). You can think of at as &quot;Do It For Me&quot;: &quot;I&#x27;m <code>T</code>, now I wanna inherit from the <code>Something</code> that&#x27;s for me, and for me only.&quot;</p><h3 id="8adfc17b-ef2b-4a07-bd74-d39a2f778271" class="">legacy nothrow operator new</h3><pre id="79cdfd69-a4de-46fa-aeb6-181855c4a3f4" class="code"><code>Widget *pw1 = new Widget; // throws bad_alloc if alloc fails
if (pw1 == 0) { } // this must fail when it&#x27;s executed

Widget *pw2 = new (std::nothrow) Widget; // returns 0 if alloc fails
if (pw2 == 0) { } // this might succeed</code></pre><p id="b34da093-a677-4dfc-91fb-94f0af4df30d" class="">Using <code>nothrow</code> guarantees that the <code>operator new</code> won&#x27;t throw, but not the ctor. Just avoid it.</p><h2 id="85724b1e-956b-4d00-8ee8-7175bbbcc00b" class="">50 When necessary, replace <code>new</code> and <code>delete</code></h2><h3 id="0d6016ae-ea4d-4fde-9cb6-9e4899d84747" class="">why the black magic</h3><ul id="6ab05fbf-46e2-4f15-be62-bfbb88c10626" class="bulleted-list"><li><strong>To detect usage errors.</strong><ul id="d34d1d40-54cd-4fe6-9c2c-8160401256b2" class="bulleted-list"><li>Keep track of the numbers of <code>new</code>s and <code>delete</code>s to prevent memory leak.</li></ul><ul id="e81a66de-5a9b-4e89-a524-656cb5e25e98" class="bulleted-list"><li>Prevent data overruns (writing beyond the end of allocated block) and underruns.<ul id="7b90c1af-2f20-4521-b7ed-c2d2c8dbe8ba" class="bulleted-list"><li>Custom <code>new</code>s can pad a few bytes as signatures, before and after the block.</li></ul><ul id="41469e24-6855-4bd7-9f44-0ec92a630326" class="bulleted-list"><li>Custom <code>delete</code>s can check the signatures and report if they&#x27;re corrupted.</li></ul></li></ul></li></ul><ul id="e688da7c-65eb-478d-a69e-7e61ade6d5b0" class="bulleted-list"><li><strong>To improve efficiency.</strong><ul id="1ee270fa-af73-4e90-938b-a27cdaa602a9" class="bulleted-list"><li>General <code>new</code> and <code>delete</code> takes a middle-of-the-road strategy.</li></ul><ul id="7235fa80-c509-46fc-a443-8a88189b5a1d" class="bulleted-list"><li>Customizing can help opinionate.</li></ul></li></ul><ul id="34e92a43-c5d9-4332-be9e-e68ff020201b" class="bulleted-list"><li><strong>To collect usage statistics.</strong><ul id="96e519d9-c0c1-4b00-a668-7da1719cc298" class="bulleted-list"><li>Distribution of block sizes and lifetimes; FIFO, LIFO or random; changes over time; max amount of allocated memory...</li></ul></li></ul><h3 id="d5438a57-c084-4d12-8531-f42f97aac04c" class="">over/underrun detection using signatures</h3><p id="24d14860-4a18-4860-a655-6b5314c1d7c4" class="">First draft, which is <strong>flawed</strong>.</p><pre id="68f7316e-a307-4899-a891-649e3d2dd081" class="code"><code>static const int signature = 0xDEADBEEF;
typedef unsigned char Byte;

void* operator new(std::size_t size) throw(std::bad_alloc) {
	using namespace std;

	size_t realSize = size + 2 * sizeof(int);
	void *pMem = malloc(realSize);
	if (!pMem) throw bad_alloc();

	// write sig to beginning and end
	*(static_cast&lt;int*&gt;(pMem)) = signature;
	*(reinterpret_cast&lt;int*&gt;(
			static_cast&lt;Byte*&gt;(pMem) + realSize - sizeof(int))) = signature;

	// return a pointer to just after the first sig
	return static_cast&lt;Byte*&gt;(pMem) + sizeof(int);
}</code></pre><h3 id="59da1662-1c3d-446c-a0cf-bce6cb7411c6" class="">alignment</h3><ul id="f0b0dcde-2b07-4984-bab8-2b379dd3888a" class="bulleted-list"><li>C++ requires all <code>operator new</code>s return pointers that are suitably aligned for <em>any</em> data type.</li></ul><ul id="9d7be02b-782a-49c0-9eda-bc75e25b85a6" class="bulleted-list"><li><code>malloc</code> guarantees this, so returning a pointer returned by <code>malloc</code> is safe.</li></ul><ul id="a77be201-0262-46f9-a471-e67723c0da36" class="bulleted-list"><li>But we returned a pointer from <code>malloc</code> offset by the size of an <code>int</code>.</li></ul><h3 id="090b3773-020d-4f6d-a4bd-50600819858d" class="">alternatives</h3><ul id="0db6dfc3-74bf-4178-9425-bb5f62958c7d" class="bulleted-list"><li>Complier switches for debugging and logging functionality.</li></ul><ul id="a56fefe7-83c7-4db5-a292-aa285f330f27" class="bulleted-list"><li>Open source or commercial libraries for memory managers.</li></ul><h2 id="4934ebc0-75b7-40ec-9c56-0dde35495a30" class="">51 Adhere to convention when writing <code>new</code> and <code>delete</code></h2><h3 id="f411806c-0998-489a-ab7c-a0c7a4ad25da" class="">ROT</h3><ul id="2482b878-3f88-4d1d-a54e-610486d56d09" class="bulleted-list"><li><code>operator new</code> should<ul id="f092d555-b93d-482e-877f-f2d6aa4fc5d9" class="bulleted-list"><li>contain infinite loop trying to allocate memory and call new-handler if fail</li></ul><ul id="d337b63e-aa9e-43e5-9844-a2ec63d5e7c2" class="bulleted-list"><li>handle requests for zero bytes</li></ul><ul id="0e534d13-21cc-4300-9d27-c34bae78ff01" class="bulleted-list"><li>for member function versions, check for size</li></ul></li></ul><ul id="77a6a777-4b0b-4571-aba8-2f107f4c8df8" class="bulleted-list"><li><code>operator delete</code> should<ul id="54aceeb8-94bf-4c56-9539-79f62603b8af" class="bulleted-list"><li>do nothing if passed <code>nullptr</code></li></ul><ul id="2b439368-df5d-4ae5-8ad6-70da9a45ade6" class="bulleted-list"><li>for member function versions, check for size</li></ul></li></ul><h3 id="99f43370-da29-40bd-bf52-7a857d10f5ae" class="">conventions for<code>new</code></h3><p id="13c800e7-e7ea-47c4-a780-8e9cf52e5900" class="">Pseudocode:</p><pre id="b2f61026-5dd9-40d1-bf0c-4a0c3d60c1f2" class="code"><code>void* operator new(std::size_t size) throw(std::bad_alloc) {
	using namespace std;
	if (size == 0) {
		size = 1;
	}
	while (true) {
		/* Try to allocate `size` bytes here */

		if (/* allocation successful */) {
			return /* pointer to allocated memory */;
		}
		// alloc failed; find out current new-handler and call
		new_handler globalHandler = set_new_handler(nullptr);
		set_new_handler(globalHandler);
		if (globalHandler) (*globalHandler)();
		else throw std::bad_alloc();
	}
}</code></pre><ul id="fa06b41a-0095-45c9-ba47-52ceca06c37c" class="bulleted-list"><li>there&#x27;s only one way to get current new-handler</li></ul><ul id="74784fac-d053-4ba6-a4e9-dbfcb0a66b8d" class="bulleted-list"><li><code>operator new</code> has an infinite loop, so writing valid new-handler is crucial</li></ul><ul id="b55fab9f-ed4b-40a7-8ac4-557bcd2e6674" class="bulleted-list"><li><code>operator new</code> is inherited by derived classes, but it might be specifically designed for the base class and will break the derived class.<ul id="49659a53-4828-43a4-b6df-f293cda0e9ed" class="toggle"><li><details open=""><summary>Add a comparison for size of the base class.</summary><p id="4cf2bc28-6d2e-4237-94cd-929650232b97" class=""><code>new</code> with zero bytes will get handled by <code>::operator new</code>.</p><pre id="9380e8d9-460d-4086-b9cf-3d955f06048d" class="code"><code>void* Base::operator new(std::size_t size) throw(std::bad_alloc) {
	if (size != sizeof(Base)) return ::operator new(size);
}</code></pre></details></li></ul></li></ul><ul id="ff56cfad-531a-4116-bcbb-66f43b961927" class="bulleted-list"><li>For <code>operator new[]</code>, do not do anything to the nonexist objects. You don&#x27;t even know how many objects are there.<ul id="e44d4591-7542-4cbf-b8f8-db6218272e37" class="bulleted-list"><li>the operator might be called on derived classes</li></ul><ul id="b5eac86f-5e17-45b8-84d7-2bb7b18b669c" class="bulleted-list"><li>there might be extra space in <code>size</code> that&#x27;s used for tracking number of elements</li></ul></li></ul><h3 id="dc16389d-9647-48ce-bf74-e321f4e1747f" class="">conventions for <code>delete</code></h3><p id="13b721f5-644c-44de-a92f-5dfaa9547364" class="">C++ guarantees it&#x27;s always safe to delete the null pointer. Typical pseudocode:</p><pre id="9b9e1cb8-837c-4b89-a3a3-2b607437bc3d" class="code"><code>void operator delete(void *rawMemory) throw() {
	if (rawMemory == nullptr) return;

	/* deallocate memory pointed to by rawMemory */
}</code></pre><p id="842c39f0-64c9-4f82-a746-29117c1405db" class="">For the member function version, also remember to check correct size:</p><pre id="9a75ee6c-bfc5-4f43-b82e-d76531e1c380" class="code"><code>void Base::operator delete(void *rawMemory, std::size_t size) throw() {
	if (rawMemory == nullptr) return;
	if (size != sizeof(Base)) {
		::operator delete(rawMemory);
		return;
	}

	/* deallocate memory pointed to by rawMemory */
}</code></pre><p id="c128417d-a1e7-4311-a550-6eca71828060" class="">Note: if the base class doesn&#x27;t have a virtual destructor, the <code>size</code> argument might be wrong.</p><h2 id="3fdf33f0-f035-4ffb-b8f6-4ad241d18df2" class="">52 Write placement <code>delete</code> if you write placement <code>new</code></h2><h3 id="a755438e-08cb-4468-bd7c-e8441295d5c5" class="">ROT</h3><ul id="4c39b661-eacb-4766-928b-8651adb8f6ba" class="bulleted-list"><li>write placement <code>new</code>/<code>delete</code> in pairs</li></ul><ul id="280a3349-a866-45e3-81b4-5f722d338111" class="bulleted-list"><li>be aware of name hiding and provide standard forms</li></ul><h3 id="46bc191f-bfcb-4f8c-93ff-5384281d2a11" class="">terminology</h3><p id="228cde41-e582-4365-907c-012dfd305ab5" class="">If an <code>operator new</code> takes extra parameters it&#x27;s called <em>placement </em><code><em>new</em></code>; If an <code>operator delete</code> takes extra parameters it&#x27;s called <em>placement </em><code>delete</code>.</p><p id="88c12a61-4779-4ebb-b44c-5b0af3468aa3" class="">Placement <code>new</code> also sometimes refer to the specific <code>operator new</code> introduced in <code>&lt;new&gt;</code>: <code>void* operator new(std::size_t, void* pMem) throw();</code>.</p><h3 id="9d7c5830-6bda-4a24-8ac4-7fb01f21df08" class="">compilers taking care of exceptions thrown when <code>new</code>ing</h3><p id="de198175-d3dc-4099-b711-9e1f32e79f47" class="">For <code>Widget *pw = new Widget;</code>, two functions are called: <code>operator new</code> and <code>Widget</code>&#x27;s default ctor. If <code>operator new</code> succeeds, memory is allocated; then if the default ctor throws, <code>operator delete</code> will be called to clean up the memory and prevent memory leak.</p><p id="e6d81df5-714c-4851-82d1-5fd07f639455" class="">It works out of the box for standard <code>new</code> and <code>delete</code>, but if you have placement <code>new</code>s, you also need to have placement <code>delete</code>s that have matching signatures.</p><h3 id="e08b50fe-aa57-4aa4-8280-ed658d72c603" class="">providing full support for <code>new</code> and <code>delete</code></h3><ul id="928ae454-4b3f-4ad5-8e14-abbfe71a39c4" class="bulleted-list"><li><code>delete ptr;</code> never calls placement <code>delete</code>s. You need to provide both forms.</li></ul><ul id="7681a988-23da-4855-9365-89bbd4a05899" class="bulleted-list"><li>Normal name hiding rules apply to <code>operator new</code>s and <code>operator delete</code>s as well.</li></ul><ul id="ccf7045b-fe42-4158-9c61-98e8e00330aa" class="bulleted-list"><li>By default, C++ offers these <code>operator new</code>s at global scope:<pre id="c51e92dd-de92-400f-a626-6d91697a272d" class="code"><code>void* operator new(std::size_t) throw(std::bad_alloc);
void* operator new(std::size_t, void*) throw();
void* operator new(std::size_t, const std::nothrow_t&amp;) throw();</code></pre></li></ul><p id="de07ef56-5db6-47ed-a167-31fe6c1af944" class="">Unless you intentionally want to hide some of these standard <code>new</code>s, you should provide all of them by forwarding them to the standard <code>new</code>/<code>delete</code>. </p><ul id="d1f56393-7da3-4567-9040-51497751b82e" class="toggle"><li><details open=""><summary>Let&#x27;s put them in a base class so it can be reused.</summary><pre id="7b1dc497-ab46-486a-82f8-1bb8db118c68" class="code"><code>class StandardNewDeleteForms {
	// normal new/delete
	static void* operator new(std::size_t size) throw(std::bad_alloc)
	{ return ::operator new(size); }
	static void operator delete(void* pMem) throw()
	{ ::operator delete(pMem); }

	// placement new/delete
	static void* operator new(std::size_t size, void* ptr) throw()
	{ return ::operator new(size, ptr); }
	static void* operator delete(void* pMem, void* ptr) throw()
	{ return ::operator delete(pMem, ptr); }

	// nothrow new/delete
	static void* operator new(std::size_t size,
														const std::nothrow_t&amp; nt) throw()
	{ return ::operator(size, nt); }
	static void* operator(void *pMem, const std::nothrow_t&amp;) throw()
	{ return ::operator delete(pMem); }
};</code></pre></details></li></ul><ul id="e70fcdb2-077e-4a4e-bebd-30fb7ff23b1e" class="toggle"><li><details open=""><summary>Clients can inherit the class and use <code>using</code>, just like in <a href="https://www.notion.so/nerrons/Effective-C-73e0037beb024637b5e5e08848f8d4fd#615a8ccb951843248fa2c29d9e333d6e">Item 33</a>.</summary><pre id="34644485-2d40-48a0-8590-612dd1fb4208" class="code"><code>class Widget : public StandardNewDeleteForms {
public:
	using StandardNewDeleteForms::operator new;
	using StandardNewDeleteForms::operator delete;

	static void* operator new(std::size_t size,
														std::ostream&amp; logStream) throw(std::bad_alloc);
	static void operator delete(void* pMem, std::ostream&amp; logStream) throw();
};</code></pre></details></li></ul><h1 id="03c5b93b-a2bf-498e-9858-1bb86afcc796" class="">Miscellany</h1><h2 id="5bc23f38-1f4b-42f6-99e1-6582e8f6bc59" class="">53 Pay attention to compiler warnings</h2><ul id="9576d8a4-9e7b-4d93-a9bb-5627aa214392" class="bulleted-list"><li>Compiler is probably smarter than you.</li></ul><ul id="651cb89b-1de8-4d6f-b5dc-23e5f0cdf7ac" class="bulleted-list"><li>Aim for the max level.</li></ul><h2 id="4b91c652-bbf0-4ea1-af82-9ac3fd926f87" class="">54 Familiarize urself with standard libraries</h2><h3 id="bb122234-7fe5-40a5-91dc-bec26e03df3f" class="">C++98</h3><ul id="876d3085-5fe2-4622-abf2-529e15133128" class="bulleted-list"><li>STL: containers, iterators, algorithms, container and function object adapters</li></ul><ul id="67a14506-fb63-4eb0-9387-c3b263f539e1" class="bulleted-list"><li>iostreams: user-defined buffering, i18n IO, predefined objects <code>cin</code>, <code>cout</code>, <code>cerr</code>, <code>clog</code></li></ul><ul id="27cae0c6-1ad9-46eb-913f-693307cc7980" class="bulleted-list"><li>i18n: multiple active locales, <code>wchar_t</code>, <code>wstring</code></li></ul><ul id="10130a52-f630-4812-8f23-905530584904" class="bulleted-list"><li>numeric processing: <code>complex</code>, <code>valarray</code></li></ul><ul id="364b9332-6210-4b6e-ac48-de2a714f6df9" class="bulleted-list"><li>exception hiearchy: base class <code>exception</code>, derived <code>logic_error</code>, <code>runtime_error</code></li></ul><ul id="f4578845-4d75-4399-b48c-29ddd8267aab" class="bulleted-list"><li>C89 standard library.</li></ul><h3 id="1fcf2339-5c49-4539-8588-24252d26c65d" class="">C++0x</h3><ul id="0457d221-db1a-4fab-8f32-575b44059a10" class="bulleted-list"><li>smart pointers</li></ul><ul id="b212b9be-9b5d-4859-a314-c94b6199ab01" class="bulleted-list"><li><code>function</code></li></ul><ul id="d7a44ebc-0e01-495b-94ec-ec250f759da5" class="bulleted-list"><li><code>bind</code></li></ul><ul id="65a85fe0-f9e9-4385-a9d4-c71e7be26d96" class="bulleted-list"><li>Other discrete functionalities:<ul id="ae762899-2862-471b-ac74-fd55a7541872" class="bulleted-list"><li>Hash tables, regex, tuples, <code>array</code>, <code>mem_fn</code>, <code>reference_wrapper</code>, rand, math, C99</li></ul></li></ul><ul id="1ea3b299-86c5-4a60-9933-9c15cfec319b" class="bulleted-list"><li>Template programming:<ul id="ea47cb22-70ab-4781-bf97-8083842d7c71" class="bulleted-list"><li>type traits, <code>result_of</code>.</li></ul></li></ul><h2 id="38e1c7ac-eea2-4722-a212-1ae60b626547" class="">55 Use <code>Boost</code>.</h2><p id="766c9c54-3a88-4d14-ae5f-a9882e0772ba" class="">
</p></div></article></body></html>
